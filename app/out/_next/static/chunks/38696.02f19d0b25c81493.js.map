{"version":3,"file":"static/chunks/38696.02f19d0b25c81493.js","mappings":"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","sources":["webpack://_N_E/../node_modules/d3-axis/src/identity.js","webpack://_N_E/../node_modules/d3-axis/src/axis.js","webpack://_N_E/../node_modules/robust-predicates/esm/util.js","webpack://_N_E/../node_modules/robust-predicates/esm/orient2d.js","webpack://_N_E/../node_modules/robust-predicates/esm/orient3d.js","webpack://_N_E/../node_modules/robust-predicates/esm/incircle.js","webpack://_N_E/../node_modules/robust-predicates/esm/insphere.js","webpack://_N_E/../node_modules/robust-predicates/index.js","webpack://_N_E/../node_modules/delaunator/index.js","webpack://_N_E/../node_modules/d3-delaunay/src/path.js","webpack://_N_E/../node_modules/d3-delaunay/src/polygon.js","webpack://_N_E/../node_modules/d3-delaunay/src/voronoi.js","webpack://_N_E/../node_modules/d3-delaunay/src/delaunay.js"],"sourcesContent":["export default function(x) {\n  return x;\n}\n","import identity from \"./identity.js\";\n\nvar top = 1,\n    right = 2,\n    bottom = 3,\n    left = 4,\n    epsilon = 1e-6;\n\nfunction translateX(x) {\n  return \"translate(\" + x + \",0)\";\n}\n\nfunction translateY(y) {\n  return \"translate(0,\" + y + \")\";\n}\n\nfunction number(scale) {\n  return d => +scale(d);\n}\n\nfunction center(scale, offset) {\n  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return d => +scale(d) + offset;\n}\n\nfunction entering() {\n  return !this.__axis;\n}\n\nfunction axis(orient, scale) {\n  var tickArguments = [],\n      tickValues = null,\n      tickFormat = null,\n      tickSizeInner = 6,\n      tickSizeOuter = 6,\n      tickPadding = 3,\n      offset = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5,\n      k = orient === top || orient === left ? -1 : 1,\n      x = orient === left || orient === right ? \"x\" : \"y\",\n      transform = orient === top || orient === bottom ? translateX : translateY;\n\n  function axis(context) {\n    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,\n        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n        range = scale.range(),\n        range0 = +range[0] + offset,\n        range1 = +range[range.length - 1] + offset,\n        position = (scale.bandwidth ? center : number)(scale.copy(), offset),\n        selection = context.selection ? context.selection() : context,\n        path = selection.selectAll(\".domain\").data([null]),\n        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n        tickExit = tick.exit(),\n        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n        line = tick.select(\"line\"),\n        text = tick.select(\"text\");\n\n    path = path.merge(path.enter().insert(\"path\", \".tick\")\n        .attr(\"class\", \"domain\")\n        .attr(\"stroke\", \"currentColor\"));\n\n    tick = tick.merge(tickEnter);\n\n    line = line.merge(tickEnter.append(\"line\")\n        .attr(\"stroke\", \"currentColor\")\n        .attr(x + \"2\", k * tickSizeInner));\n\n    text = text.merge(tickEnter.append(\"text\")\n        .attr(\"fill\", \"currentColor\")\n        .attr(x, k * spacing)\n        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\n    if (context !== selection) {\n      path = path.transition(context);\n      tick = tick.transition(context);\n      line = line.transition(context);\n      text = text.transition(context);\n\n      tickExit = tickExit.transition(context)\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute(\"transform\"); });\n\n      tickEnter\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });\n    }\n\n    tickExit.remove();\n\n    path\n        .attr(\"d\", orient === left || orient === right\n            ? (tickSizeOuter ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H\" + offset + \"V\" + range1 + \"H\" + k * tickSizeOuter : \"M\" + offset + \",\" + range0 + \"V\" + range1)\n            : (tickSizeOuter ? \"M\" + range0 + \",\" + k * tickSizeOuter + \"V\" + offset + \"H\" + range1 + \"V\" + k * tickSizeOuter : \"M\" + range0 + \",\" + offset + \"H\" + range1));\n\n    tick\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", function(d) { return transform(position(d) + offset); });\n\n    line\n        .attr(x + \"2\", k * tickSizeInner);\n\n    text\n        .attr(x, k * spacing)\n        .text(format);\n\n    selection.filter(entering)\n        .attr(\"fill\", \"none\")\n        .attr(\"font-size\", 10)\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\n    selection\n        .each(function() { this.__axis = position; });\n  }\n\n  axis.scale = function(_) {\n    return arguments.length ? (scale = _, axis) : scale;\n  };\n\n  axis.ticks = function() {\n    return tickArguments = Array.from(arguments), axis;\n  };\n\n  axis.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();\n  };\n\n  axis.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();\n  };\n\n  axis.tickFormat = function(_) {\n    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n  };\n\n  axis.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n  };\n\n  axis.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n  };\n\n  axis.offset = function(_) {\n    return arguments.length ? (offset = +_, axis) : offset;\n  };\n\n  return axis;\n}\n\nexport function axisTop(scale) {\n  return axis(top, scale);\n}\n\nexport function axisRight(scale) {\n  return axis(right, scale);\n}\n\nexport function axisBottom(scale) {\n  return axis(bottom, scale);\n}\n\nexport function axisLeft(scale) {\n  return axis(left, scale);\n}\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum, scale} from './util.js';\n\nconst o3derrboundA = (7 + 56 * epsilon) * epsilon;\nconst o3derrboundB = (3 + 28 * epsilon) * epsilon;\nconst o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;\n\nconst bc = vec(4);\nconst ca = vec(4);\nconst ab = vec(4);\nconst at_b = vec(4);\nconst at_c = vec(4);\nconst bt_c = vec(4);\nconst bt_a = vec(4);\nconst ct_a = vec(4);\nconst ct_b = vec(4);\nconst bct = vec(8);\nconst cat = vec(8);\nconst abt = vec(8);\nconst u = vec(4);\n\nconst _8 = vec(8);\nconst _8b = vec(8);\nconst _16 = vec(8);\nconst _12 = vec(12);\n\nlet fin = vec(192);\nlet fin2 = vec(192);\n\nfunction finadd(finlen, alen, a) {\n    finlen = sum(finlen, fin, alen, a, fin2);\n    const tmp = fin; fin = fin2; fin2 = tmp;\n    return finlen;\n}\n\nfunction tailinit(xtail, ytail, ax, ay, bx, by, a, b) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3, negate;\n    if (xtail === 0) {\n        if (ytail === 0) {\n            a[0] = 0;\n            b[0] = 0;\n            return 1;\n        } else {\n            negate = -ytail;\n            s1 = negate * ax;\n            c = splitter * negate;\n            ahi = c - (c - negate);\n            alo = negate - ahi;\n            c = splitter * ax;\n            bhi = c - (c - ax);\n            blo = ax - bhi;\n            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            a[1] = s1;\n            s1 = ytail * bx;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * bx;\n            bhi = c - (c - bx);\n            blo = bx - bhi;\n            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            b[1] = s1;\n            return 2;\n        }\n    } else {\n        if (ytail === 0) {\n            s1 = xtail * ay;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * ay;\n            bhi = c - (c - ay);\n            blo = ay - bhi;\n            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            a[1] = s1;\n            negate = -xtail;\n            s1 = negate * by;\n            c = splitter * negate;\n            ahi = c - (c - negate);\n            alo = negate - ahi;\n            c = splitter * by;\n            bhi = c - (c - by);\n            blo = by - bhi;\n            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            b[1] = s1;\n            return 2;\n        } else {\n            s1 = xtail * ay;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * ay;\n            bhi = c - (c - ay);\n            blo = ay - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = ytail * ax;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * ax;\n            bhi = c - (c - ax);\n            blo = ax - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            a[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            a[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            a[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            a[3] = u3;\n            s1 = ytail * bx;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * bx;\n            bhi = c - (c - bx);\n            blo = bx - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = xtail * by;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * by;\n            bhi = c - (c - by);\n            blo = by - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            b[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            b[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            b[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            b[3] = u3;\n            return 4;\n        }\n    }\n}\n\nfunction tailadd(finlen, a, b, k, z) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, u3;\n    s1 = a * b;\n    c = splitter * a;\n    ahi = c - (c - a);\n    alo = a - ahi;\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    c = splitter * k;\n    bhi = c - (c - k);\n    blo = k - bhi;\n    _i = s0 * k;\n    c = splitter * s0;\n    ahi = c - (c - s0);\n    alo = s0 - ahi;\n    u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);\n    _j = s1 * k;\n    c = splitter * s1;\n    ahi = c - (c - s1);\n    alo = s1 - ahi;\n    _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);\n    _k = _i + _0;\n    bvirt = _k - _i;\n    u[1] = _i - (_k - bvirt) + (_0 - bvirt);\n    u3 = _j + _k;\n    u[2] = _k - (u3 - _j);\n    u[3] = u3;\n    finlen = finadd(finlen, 4, u);\n    if (z !== 0) {\n        c = splitter * z;\n        bhi = c - (c - z);\n        blo = z - bhi;\n        _i = s0 * z;\n        c = splitter * s0;\n        ahi = c - (c - s0);\n        alo = s0 - ahi;\n        u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);\n        _j = s1 * z;\n        c = splitter * s1;\n        ahi = c - (c - s1);\n        alo = s1 - ahi;\n        _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);\n        _k = _i + _0;\n        bvirt = _k - _i;\n        u[1] = _i - (_k - bvirt) + (_0 - bvirt);\n        u3 = _j + _k;\n        u[2] = _k - (u3 - _j);\n        u[3] = u3;\n        finlen = finadd(finlen, 4, u);\n    }\n    return finlen;\n}\n\nfunction orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent) {\n    let finlen;\n    let adxtail, bdxtail, cdxtail;\n    let adytail, bdytail, cdytail;\n    let adztail, bdztail, cdztail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3;\n\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    s1 = bdx * cdy;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cdx * bdy;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cdx * ady;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = adx * cdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ca[3] = u3;\n    s1 = adx * bdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bdx * ady;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n\n    finlen = sum(\n        sum(\n            scale(4, bc, adz, _8), _8,\n            scale(4, ca, bdz, _8b), _8b, _16), _16,\n        scale(4, ab, cdz, _8), _8, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = o3derrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - adx;\n    adxtail = ax - (adx + bvirt) + (bvirt - dx);\n    bvirt = bx - bdx;\n    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);\n    bvirt = cx - cdx;\n    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);\n    bvirt = ay - ady;\n    adytail = ay - (ady + bvirt) + (bvirt - dy);\n    bvirt = by - bdy;\n    bdytail = by - (bdy + bvirt) + (bvirt - dy);\n    bvirt = cy - cdy;\n    cdytail = cy - (cdy + bvirt) + (bvirt - dy);\n    bvirt = az - adz;\n    adztail = az - (adz + bvirt) + (bvirt - dz);\n    bvirt = bz - bdz;\n    bdztail = bz - (bdz + bvirt) + (bvirt - dz);\n    bvirt = cz - cdz;\n    cdztail = cz - (cdz + bvirt) + (bvirt - dz);\n\n    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 &&\n        adytail === 0 && bdytail === 0 && cdytail === 0 &&\n        adztail === 0 && bdztail === 0 && cdztail === 0) {\n        return det;\n    }\n\n    errbound = o3derrboundC * permanent + resulterrbound * Math.abs(det);\n    det +=\n        adz * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + adztail * (bdx * cdy - bdy * cdx) +\n        bdz * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + bdztail * (cdx * ady - cdy * adx) +\n        cdz * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + cdztail * (adx * bdy - ady * bdx);\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    const at_len = tailinit(adxtail, adytail, bdx, bdy, cdx, cdy, at_b, at_c);\n    const bt_len = tailinit(bdxtail, bdytail, cdx, cdy, adx, ady, bt_c, bt_a);\n    const ct_len = tailinit(cdxtail, cdytail, adx, ady, bdx, bdy, ct_a, ct_b);\n\n    const bctlen = sum(bt_len, bt_c, ct_len, ct_b, bct);\n    finlen = finadd(finlen, scale(bctlen, bct, adz, _16), _16);\n\n    const catlen = sum(ct_len, ct_a, at_len, at_c, cat);\n    finlen = finadd(finlen, scale(catlen, cat, bdz, _16), _16);\n\n    const abtlen = sum(at_len, at_b, bt_len, bt_a, abt);\n    finlen = finadd(finlen, scale(abtlen, abt, cdz, _16), _16);\n\n    if (adztail !== 0) {\n        finlen = finadd(finlen, scale(4, bc, adztail, _12), _12);\n        finlen = finadd(finlen, scale(bctlen, bct, adztail, _16), _16);\n    }\n    if (bdztail !== 0) {\n        finlen = finadd(finlen, scale(4, ca, bdztail, _12), _12);\n        finlen = finadd(finlen, scale(catlen, cat, bdztail, _16), _16);\n    }\n    if (cdztail !== 0) {\n        finlen = finadd(finlen, scale(4, ab, cdztail, _12), _12);\n        finlen = finadd(finlen, scale(abtlen, abt, cdztail, _16), _16);\n    }\n\n    if (adxtail !== 0) {\n        if (bdytail !== 0) {\n            finlen = tailadd(finlen, adxtail, bdytail, cdz, cdztail);\n        }\n        if (cdytail !== 0) {\n            finlen = tailadd(finlen, -adxtail, cdytail, bdz, bdztail);\n        }\n    }\n    if (bdxtail !== 0) {\n        if (cdytail !== 0) {\n            finlen = tailadd(finlen, bdxtail, cdytail, adz, adztail);\n        }\n        if (adytail !== 0) {\n            finlen = tailadd(finlen, -bdxtail, adytail, cdz, cdztail);\n        }\n    }\n    if (cdxtail !== 0) {\n        if (adytail !== 0) {\n            finlen = tailadd(finlen, cdxtail, adytail, bdz, bdztail);\n        }\n        if (bdytail !== 0) {\n            finlen = tailadd(finlen, -cdxtail, bdytail, adz, adztail);\n        }\n    }\n\n    return fin[finlen - 1];\n}\n\nexport function orient3d(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    const bdxcdy = bdx * cdy;\n    const cdxbdy = cdx * bdy;\n\n    const cdxady = cdx * ady;\n    const adxcdy = adx * cdy;\n\n    const adxbdy = adx * bdy;\n    const bdxady = bdx * ady;\n\n    const det =\n        adz * (bdxcdy - cdxbdy) +\n        bdz * (cdxady - adxcdy) +\n        cdz * (adxbdy - bdxady);\n\n    const permanent =\n        (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) +\n        (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) +\n        (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);\n\n    const errbound = o3derrboundA * permanent;\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n\n    return orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent);\n}\n\nexport function orient3dfast(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    return adx * (bdy * cdz - bdz * cdy) +\n        bdx * (cdy * adz - cdz * ady) +\n        cdx * (ady * bdz - adz * bdy);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum, sum_three, scale} from './util.js';\n\nconst iccerrboundA = (10 + 96 * epsilon) * epsilon;\nconst iccerrboundB = (4 + 48 * epsilon) * epsilon;\nconst iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;\n\nconst bc = vec(4);\nconst ca = vec(4);\nconst ab = vec(4);\nconst aa = vec(4);\nconst bb = vec(4);\nconst cc = vec(4);\nconst u = vec(4);\nconst v = vec(4);\nconst axtbc = vec(8);\nconst aytbc = vec(8);\nconst bxtca = vec(8);\nconst bytca = vec(8);\nconst cxtab = vec(8);\nconst cytab = vec(8);\nconst abt = vec(8);\nconst bct = vec(8);\nconst cat = vec(8);\nconst abtt = vec(4);\nconst bctt = vec(4);\nconst catt = vec(4);\n\nconst _8 = vec(8);\nconst _16 = vec(16);\nconst _16b = vec(16);\nconst _16c = vec(16);\nconst _32 = vec(32);\nconst _32b = vec(32);\nconst _48 = vec(48);\nconst _64 = vec(64);\n\nlet fin = vec(1152);\nlet fin2 = vec(1152);\n\nfunction finadd(finlen, a, alen) {\n    finlen = sum(finlen, fin, a, alen, fin2);\n    const tmp = fin; fin = fin2; fin2 = tmp;\n    return finlen;\n}\n\nfunction incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {\n    let finlen;\n    let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;\n    let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;\n    let abtlen, bctlen, catlen;\n    let abttlen, bcttlen, cattlen;\n    let n1, n0;\n\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n\n    s1 = bdx * cdy;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cdx * bdy;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cdx * ady;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = adx * cdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ca[3] = u3;\n    s1 = adx * bdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bdx * ady;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n\n    finlen = sum(\n        sum(\n            sum(\n                scale(scale(4, bc, adx, _8), _8, adx, _16), _16,\n                scale(scale(4, bc, ady, _8), _8, ady, _16b), _16b, _32), _32,\n            sum(\n                scale(scale(4, ca, bdx, _8), _8, bdx, _16), _16,\n                scale(scale(4, ca, bdy, _8), _8, bdy, _16b), _16b, _32b), _32b, _64), _64,\n        sum(\n            scale(scale(4, ab, cdx, _8), _8, cdx, _16), _16,\n            scale(scale(4, ab, cdy, _8), _8, cdy, _16b), _16b, _32), _32, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = iccerrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - adx;\n    adxtail = ax - (adx + bvirt) + (bvirt - dx);\n    bvirt = ay - ady;\n    adytail = ay - (ady + bvirt) + (bvirt - dy);\n    bvirt = bx - bdx;\n    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);\n    bvirt = by - bdy;\n    bdytail = by - (bdy + bvirt) + (bvirt - dy);\n    bvirt = cx - cdx;\n    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);\n    bvirt = cy - cdy;\n    cdytail = cy - (cdy + bvirt) + (bvirt - dy);\n    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {\n        return det;\n    }\n\n    errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);\n    det += ((adx * adx + ady * ady) * ((bdx * cdytail + cdy * bdxtail) - (bdy * cdxtail + cdx * bdytail)) +\n        2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx)) +\n        ((bdx * bdx + bdy * bdy) * ((cdx * adytail + ady * cdxtail) - (cdy * adxtail + adx * cdytail)) +\n        2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) +\n        ((cdx * cdx + cdy * cdy) * ((adx * bdytail + bdy * adxtail) - (ady * bdxtail + bdx * adytail)) +\n        2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));\n\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {\n        s1 = adx * adx;\n        c = splitter * adx;\n        ahi = c - (c - adx);\n        alo = adx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = ady * ady;\n        c = splitter * ady;\n        ahi = c - (c - ady);\n        alo = ady - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        aa[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        aa[3] = u3;\n    }\n    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {\n        s1 = bdx * bdx;\n        c = splitter * bdx;\n        ahi = c - (c - bdx);\n        alo = bdx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = bdy * bdy;\n        c = splitter * bdy;\n        ahi = c - (c - bdy);\n        alo = bdy - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        bb[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        bb[3] = u3;\n    }\n    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {\n        s1 = cdx * cdx;\n        c = splitter * cdx;\n        ahi = c - (c - cdx);\n        alo = cdx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = cdy * cdy;\n        c = splitter * cdy;\n        ahi = c - (c - cdy);\n        alo = cdy - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        cc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        cc[3] = u3;\n    }\n\n    if (adxtail !== 0) {\n        axtbclen = scale(4, bc, adxtail, axtbc);\n        finlen = finadd(finlen, sum_three(\n            scale(axtbclen, axtbc, 2 * adx, _16), _16,\n            scale(scale(4, cc, adxtail, _8), _8, bdy, _16b), _16b,\n            scale(scale(4, bb, adxtail, _8), _8, -cdy, _16c), _16c, _32, _48), _48);\n    }\n    if (adytail !== 0) {\n        aytbclen = scale(4, bc, adytail, aytbc);\n        finlen = finadd(finlen, sum_three(\n            scale(aytbclen, aytbc, 2 * ady, _16), _16,\n            scale(scale(4, bb, adytail, _8), _8, cdx, _16b), _16b,\n            scale(scale(4, cc, adytail, _8), _8, -bdx, _16c), _16c, _32, _48), _48);\n    }\n    if (bdxtail !== 0) {\n        bxtcalen = scale(4, ca, bdxtail, bxtca);\n        finlen = finadd(finlen, sum_three(\n            scale(bxtcalen, bxtca, 2 * bdx, _16), _16,\n            scale(scale(4, aa, bdxtail, _8), _8, cdy, _16b), _16b,\n            scale(scale(4, cc, bdxtail, _8), _8, -ady, _16c), _16c, _32, _48), _48);\n    }\n    if (bdytail !== 0) {\n        bytcalen = scale(4, ca, bdytail, bytca);\n        finlen = finadd(finlen, sum_three(\n            scale(bytcalen, bytca, 2 * bdy, _16), _16,\n            scale(scale(4, cc, bdytail, _8), _8, adx, _16b), _16b,\n            scale(scale(4, aa, bdytail, _8), _8, -cdx, _16c), _16c, _32, _48), _48);\n    }\n    if (cdxtail !== 0) {\n        cxtablen = scale(4, ab, cdxtail, cxtab);\n        finlen = finadd(finlen, sum_three(\n            scale(cxtablen, cxtab, 2 * cdx, _16), _16,\n            scale(scale(4, bb, cdxtail, _8), _8, ady, _16b), _16b,\n            scale(scale(4, aa, cdxtail, _8), _8, -bdy, _16c), _16c, _32, _48), _48);\n    }\n    if (cdytail !== 0) {\n        cytablen = scale(4, ab, cdytail, cytab);\n        finlen = finadd(finlen, sum_three(\n            scale(cytablen, cytab, 2 * cdy, _16), _16,\n            scale(scale(4, aa, cdytail, _8), _8, bdx, _16b), _16b,\n            scale(scale(4, bb, cdytail, _8), _8, -adx, _16c), _16c, _32, _48), _48);\n    }\n\n    if (adxtail !== 0 || adytail !== 0) {\n        if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {\n            s1 = bdxtail * cdy;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * cdy;\n            bhi = c - (c - cdy);\n            blo = cdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdx * cdytail;\n            c = splitter * bdx;\n            ahi = c - (c - bdx);\n            alo = bdx - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            s1 = cdxtail * -bdy;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * -bdy;\n            bhi = c - (c - -bdy);\n            blo = -bdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdx * -bdytail;\n            c = splitter * cdx;\n            ahi = c - (c - cdx);\n            alo = cdx - ahi;\n            c = splitter * -bdytail;\n            bhi = c - (c - -bdytail);\n            blo = -bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            bctlen = sum(4, u, 4, v, bct);\n            s1 = bdxtail * cdytail;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdxtail * bdytail;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            bctt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            bctt[3] = u3;\n            bcttlen = 4;\n        } else {\n            bct[0] = 0;\n            bctlen = 1;\n            bctt[0] = 0;\n            bcttlen = 1;\n        }\n        if (adxtail !== 0) {\n            const len = scale(bctlen, bct, adxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(axtbclen, axtbc, adxtail, _16), _16,\n                scale(len, _16c, 2 * adx, _32), _32, _48), _48);\n\n            const len2 = scale(bcttlen, bctt, adxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * adx, _16), _16,\n                scale(len2, _8, adxtail, _16b), _16b,\n                scale(len, _16c, adxtail, _32), _32, _32b, _64), _64);\n\n            if (bdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, cc, adxtail, _8), _8, bdytail, _16), _16);\n            }\n            if (cdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, bb, -adxtail, _8), _8, cdytail, _16), _16);\n            }\n        }\n        if (adytail !== 0) {\n            const len = scale(bctlen, bct, adytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(aytbclen, aytbc, adytail, _16), _16,\n                scale(len, _16c, 2 * ady, _32), _32, _48), _48);\n\n            const len2 = scale(bcttlen, bctt, adytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * ady, _16), _16,\n                scale(len2, _8, adytail, _16b), _16b,\n                scale(len, _16c, adytail, _32), _32, _32b, _64), _64);\n        }\n    }\n    if (bdxtail !== 0 || bdytail !== 0) {\n        if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {\n            s1 = cdxtail * ady;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * ady;\n            bhi = c - (c - ady);\n            blo = ady - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdx * adytail;\n            c = splitter * cdx;\n            ahi = c - (c - cdx);\n            alo = cdx - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            n1 = -cdy;\n            n0 = -cdytail;\n            s1 = adxtail * n1;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * n1;\n            bhi = c - (c - n1);\n            blo = n1 - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adx * n0;\n            c = splitter * adx;\n            ahi = c - (c - adx);\n            alo = adx - ahi;\n            c = splitter * n0;\n            bhi = c - (c - n0);\n            blo = n0 - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            catlen = sum(4, u, 4, v, cat);\n            s1 = cdxtail * adytail;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adxtail * cdytail;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            catt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            catt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            catt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            catt[3] = u3;\n            cattlen = 4;\n        } else {\n            cat[0] = 0;\n            catlen = 1;\n            catt[0] = 0;\n            cattlen = 1;\n        }\n        if (bdxtail !== 0) {\n            const len = scale(catlen, cat, bdxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(bxtcalen, bxtca, bdxtail, _16), _16,\n                scale(len, _16c, 2 * bdx, _32), _32, _48), _48);\n\n            const len2 = scale(cattlen, catt, bdxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * bdx, _16), _16,\n                scale(len2, _8, bdxtail, _16b), _16b,\n                scale(len, _16c, bdxtail, _32), _32, _32b, _64), _64);\n\n            if (cdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, aa, bdxtail, _8), _8, cdytail, _16), _16);\n            }\n            if (adytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, cc, -bdxtail, _8), _8, adytail, _16), _16);\n            }\n        }\n        if (bdytail !== 0) {\n            const len = scale(catlen, cat, bdytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(bytcalen, bytca, bdytail, _16), _16,\n                scale(len, _16c, 2 * bdy, _32), _32, _48), _48);\n\n            const len2 = scale(cattlen, catt, bdytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * bdy, _16), _16,\n                scale(len2, _8, bdytail, _16b), _16b,\n                scale(len, _16c, bdytail, _32), _32,  _32b, _64), _64);\n        }\n    }\n    if (cdxtail !== 0 || cdytail !== 0) {\n        if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {\n            s1 = adxtail * bdy;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * bdy;\n            bhi = c - (c - bdy);\n            blo = bdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adx * bdytail;\n            c = splitter * adx;\n            ahi = c - (c - adx);\n            alo = adx - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            n1 = -ady;\n            n0 = -adytail;\n            s1 = bdxtail * n1;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * n1;\n            bhi = c - (c - n1);\n            blo = n1 - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdx * n0;\n            c = splitter * bdx;\n            ahi = c - (c - bdx);\n            alo = bdx - ahi;\n            c = splitter * n0;\n            bhi = c - (c - n0);\n            blo = n0 - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            abtlen = sum(4, u, 4, v, abt);\n            s1 = adxtail * bdytail;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdxtail * adytail;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            abtt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            abtt[3] = u3;\n            abttlen = 4;\n        } else {\n            abt[0] = 0;\n            abtlen = 1;\n            abtt[0] = 0;\n            abttlen = 1;\n        }\n        if (cdxtail !== 0) {\n            const len = scale(abtlen, abt, cdxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(cxtablen, cxtab, cdxtail, _16), _16,\n                scale(len, _16c, 2 * cdx, _32), _32, _48), _48);\n\n            const len2 = scale(abttlen, abtt, cdxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * cdx, _16), _16,\n                scale(len2, _8, cdxtail, _16b), _16b,\n                scale(len, _16c, cdxtail, _32), _32, _32b, _64), _64);\n\n            if (adytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, bb, cdxtail, _8), _8, adytail, _16), _16);\n            }\n            if (bdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, aa, -cdxtail, _8), _8, bdytail, _16), _16);\n            }\n        }\n        if (cdytail !== 0) {\n            const len = scale(abtlen, abt, cdytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(cytablen, cytab, cdytail, _16), _16,\n                scale(len, _16c, 2 * cdy, _32), _32, _48), _48);\n\n            const len2 = scale(abttlen, abtt, cdytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * cdy, _16), _16,\n                scale(len2, _8, cdytail, _16b), _16b,\n                scale(len, _16c, cdytail, _32), _32, _32b, _64), _64);\n        }\n    }\n\n    return fin[finlen - 1];\n}\n\nexport function incircle(ax, ay, bx, by, cx, cy, dx, dy) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n\n    const bdxcdy = bdx * cdy;\n    const cdxbdy = cdx * bdy;\n    const alift = adx * adx + ady * ady;\n\n    const cdxady = cdx * ady;\n    const adxcdy = adx * cdy;\n    const blift = bdx * bdx + bdy * bdy;\n\n    const adxbdy = adx * bdy;\n    const bdxady = bdx * ady;\n    const clift = cdx * cdx + cdy * cdy;\n\n    const det =\n        alift * (bdxcdy - cdxbdy) +\n        blift * (cdxady - adxcdy) +\n        clift * (adxbdy - bdxady);\n\n    const permanent =\n        (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift +\n        (Math.abs(cdxady) + Math.abs(adxcdy)) * blift +\n        (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;\n\n    const errbound = iccerrboundA * permanent;\n\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n    return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);\n}\n\nexport function incirclefast(ax, ay, bx, by, cx, cy, dx, dy) {\n    const adx = ax - dx;\n    const ady = ay - dy;\n    const bdx = bx - dx;\n    const bdy = by - dy;\n    const cdx = cx - dx;\n    const cdy = cy - dy;\n\n    const abdet = adx * bdy - bdx * ady;\n    const bcdet = bdx * cdy - cdx * bdy;\n    const cadet = cdx * ady - adx * cdy;\n    const alift = adx * adx + ady * ady;\n    const blift = bdx * bdx + bdy * bdy;\n    const clift = cdx * cdx + cdy * cdy;\n\n    return alift * bcdet + blift * cadet + clift * abdet;\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum, sum_three, scale, negate} from './util.js';\n\nconst isperrboundA = (16 + 224 * epsilon) * epsilon;\nconst isperrboundB = (5 + 72 * epsilon) * epsilon;\nconst isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;\n\nconst ab = vec(4);\nconst bc = vec(4);\nconst cd = vec(4);\nconst de = vec(4);\nconst ea = vec(4);\nconst ac = vec(4);\nconst bd = vec(4);\nconst ce = vec(4);\nconst da = vec(4);\nconst eb = vec(4);\n\nconst abc = vec(24);\nconst bcd = vec(24);\nconst cde = vec(24);\nconst dea = vec(24);\nconst eab = vec(24);\nconst abd = vec(24);\nconst bce = vec(24);\nconst cda = vec(24);\nconst deb = vec(24);\nconst eac = vec(24);\n\nconst adet = vec(1152);\nconst bdet = vec(1152);\nconst cdet = vec(1152);\nconst ddet = vec(1152);\nconst edet = vec(1152);\nconst abdet = vec(2304);\nconst cddet = vec(2304);\nconst cdedet = vec(3456);\nconst deter = vec(5760);\n\nconst _8 = vec(8);\nconst _8b = vec(8);\nconst _8c = vec(8);\nconst _16 = vec(16);\nconst _24 = vec(24);\nconst _48 = vec(48);\nconst _48b = vec(48);\nconst _96 = vec(96);\nconst _192 = vec(192);\nconst _384x = vec(384);\nconst _384y = vec(384);\nconst _384z = vec(384);\nconst _768 = vec(768);\n\nfunction sum_three_scale(a, b, c, az, bz, cz, out) {\n    return sum_three(\n        scale(4, a, az, _8), _8,\n        scale(4, b, bz, _8b), _8b,\n        scale(4, c, cz, _8c), _8c, _16, out);\n}\n\nfunction liftexact(alen, a, blen, b, clen, c, dlen, d, x, y, z, out) {\n    const len = sum(\n        sum(alen, a, blen, b, _48), _48,\n        negate(sum(clen, c, dlen, d, _48b), _48b), _48b, _96);\n\n    return sum_three(\n        scale(scale(len, _96, x, _192), _192, x, _384x), _384x,\n        scale(scale(len, _96, y, _192), _192, y, _384y), _384y,\n        scale(scale(len, _96, z, _192), _192, z, _384z), _384z, _768, out);\n}\n\nfunction insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    s1 = ax * by;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bx * ay;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n    s1 = bx * cy;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cx * by;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cx * dy;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dx * cy;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    cd[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    cd[3] = u3;\n    s1 = dx * ey;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ex * dy;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    de[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    de[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    de[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    de[3] = u3;\n    s1 = ex * ay;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ax * ey;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ea[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ea[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ea[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ea[3] = u3;\n    s1 = ax * cy;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cx * ay;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ac[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ac[3] = u3;\n    s1 = bx * dy;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dx * by;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bd[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bd[3] = u3;\n    s1 = cx * ey;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ex * cy;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ce[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ce[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ce[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ce[3] = u3;\n    s1 = dx * ay;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ax * dy;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    da[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    da[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    da[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    da[3] = u3;\n    s1 = ex * by;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bx * ey;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    eb[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    eb[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    eb[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    eb[3] = u3;\n\n    const abclen = sum_three_scale(ab, bc, ac, cz, az, -bz, abc);\n    const bcdlen = sum_three_scale(bc, cd, bd, dz, bz, -cz, bcd);\n    const cdelen = sum_three_scale(cd, de, ce, ez, cz, -dz, cde);\n    const dealen = sum_three_scale(de, ea, da, az, dz, -ez, dea);\n    const eablen = sum_three_scale(ea, ab, eb, bz, ez, -az, eab);\n    const abdlen = sum_three_scale(ab, bd, da, dz, az, bz, abd);\n    const bcelen = sum_three_scale(bc, ce, eb, ez, bz, cz, bce);\n    const cdalen = sum_three_scale(cd, da, ac, az, cz, dz, cda);\n    const deblen = sum_three_scale(de, eb, bd, bz, dz, ez, deb);\n    const eaclen = sum_three_scale(ea, ac, ce, cz, ez, az, eac);\n\n    const deterlen = sum_three(\n        liftexact(cdelen, cde, bcelen, bce, deblen, deb, bcdlen, bcd, ax, ay, az, adet), adet,\n        liftexact(dealen, dea, cdalen, cda, eaclen, eac, cdelen, cde, bx, by, bz, bdet), bdet,\n        sum_three(\n            liftexact(eablen, eab, deblen, deb, abdlen, abd, dealen, dea, cx, cy, cz, cdet), cdet,\n            liftexact(abclen, abc, eaclen, eac, bcelen, bce, eablen, eab, dx, dy, dz, ddet), ddet,\n            liftexact(bcdlen, bcd, abdlen, abd, cdalen, cda, abclen, abc, ex, ey, ez, edet), edet, cddet, cdedet), cdedet, abdet, deter);\n\n    return deter[deterlen - 1];\n}\n\nconst xdet = vec(96);\nconst ydet = vec(96);\nconst zdet = vec(96);\nconst fin = vec(1152);\n\nfunction liftadapt(a, b, c, az, bz, cz, x, y, z, out) {\n    const len = sum_three_scale(a, b, c, az, bz, cz, _24);\n    return sum_three(\n        scale(scale(len, _24, x, _48), _48, x, xdet), xdet,\n        scale(scale(len, _24, y, _48), _48, y, ydet), ydet,\n        scale(scale(len, _24, z, _48), _48, z, zdet), zdet, _192, out);\n}\n\nfunction insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent) {\n    let ab3, bc3, cd3, da3, ac3, bd3;\n\n    let aextail, bextail, cextail, dextail;\n    let aeytail, beytail, ceytail, deytail;\n    let aeztail, beztail, ceztail, deztail;\n\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0;\n\n    const aex = ax - ex;\n    const bex = bx - ex;\n    const cex = cx - ex;\n    const dex = dx - ex;\n    const aey = ay - ey;\n    const bey = by - ey;\n    const cey = cy - ey;\n    const dey = dy - ey;\n    const aez = az - ez;\n    const bez = bz - ez;\n    const cez = cz - ez;\n    const dez = dz - ez;\n\n    s1 = aex * bey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bex * aey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    ab3 = _j + _i;\n    bvirt = ab3 - _j;\n    ab[2] = _j - (ab3 - bvirt) + (_i - bvirt);\n    ab[3] = ab3;\n    s1 = bex * cey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cex * bey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    bc3 = _j + _i;\n    bvirt = bc3 - _j;\n    bc[2] = _j - (bc3 - bvirt) + (_i - bvirt);\n    bc[3] = bc3;\n    s1 = cex * dey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dex * cey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    cd3 = _j + _i;\n    bvirt = cd3 - _j;\n    cd[2] = _j - (cd3 - bvirt) + (_i - bvirt);\n    cd[3] = cd3;\n    s1 = dex * aey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = aex * dey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    da[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    da[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    da3 = _j + _i;\n    bvirt = da3 - _j;\n    da[2] = _j - (da3 - bvirt) + (_i - bvirt);\n    da[3] = da3;\n    s1 = aex * cey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cex * aey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    ac3 = _j + _i;\n    bvirt = ac3 - _j;\n    ac[2] = _j - (ac3 - bvirt) + (_i - bvirt);\n    ac[3] = ac3;\n    s1 = bex * dey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dex * bey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    bd3 = _j + _i;\n    bvirt = bd3 - _j;\n    bd[2] = _j - (bd3 - bvirt) + (_i - bvirt);\n    bd[3] = bd3;\n\n    const finlen = sum(\n        sum(\n            negate(liftadapt(bc, cd, bd, dez, bez, -cez, aex, aey, aez, adet), adet), adet,\n            liftadapt(cd, da, ac, aez, cez, dez, bex, bey, bez, bdet), bdet, abdet), abdet,\n        sum(\n            negate(liftadapt(da, ab, bd, bez, dez, aez, cex, cey, cez, cdet), cdet), cdet,\n            liftadapt(ab, bc, ac, cez, aez, -bez, dex, dey, dez, ddet), ddet, cddet), cddet, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = isperrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - aex;\n    aextail = ax - (aex + bvirt) + (bvirt - ex);\n    bvirt = ay - aey;\n    aeytail = ay - (aey + bvirt) + (bvirt - ey);\n    bvirt = az - aez;\n    aeztail = az - (aez + bvirt) + (bvirt - ez);\n    bvirt = bx - bex;\n    bextail = bx - (bex + bvirt) + (bvirt - ex);\n    bvirt = by - bey;\n    beytail = by - (bey + bvirt) + (bvirt - ey);\n    bvirt = bz - bez;\n    beztail = bz - (bez + bvirt) + (bvirt - ez);\n    bvirt = cx - cex;\n    cextail = cx - (cex + bvirt) + (bvirt - ex);\n    bvirt = cy - cey;\n    ceytail = cy - (cey + bvirt) + (bvirt - ey);\n    bvirt = cz - cez;\n    ceztail = cz - (cez + bvirt) + (bvirt - ez);\n    bvirt = dx - dex;\n    dextail = dx - (dex + bvirt) + (bvirt - ex);\n    bvirt = dy - dey;\n    deytail = dy - (dey + bvirt) + (bvirt - ey);\n    bvirt = dz - dez;\n    deztail = dz - (dez + bvirt) + (bvirt - ez);\n    if (aextail === 0 && aeytail === 0 && aeztail === 0 &&\n        bextail === 0 && beytail === 0 && beztail === 0 &&\n        cextail === 0 && ceytail === 0 && ceztail === 0 &&\n        dextail === 0 && deytail === 0 && deztail === 0) {\n        return det;\n    }\n\n    errbound = isperrboundC * permanent + resulterrbound * Math.abs(det);\n\n    const abeps = (aex * beytail + bey * aextail) - (aey * bextail + bex * aeytail);\n    const bceps = (bex * ceytail + cey * bextail) - (bey * cextail + cex * beytail);\n    const cdeps = (cex * deytail + dey * cextail) - (cey * dextail + dex * ceytail);\n    const daeps = (dex * aeytail + aey * dextail) - (dey * aextail + aex * deytail);\n    const aceps = (aex * ceytail + cey * aextail) - (aey * cextail + cex * aeytail);\n    const bdeps = (bex * deytail + dey * bextail) - (bey * dextail + dex * beytail);\n    det +=\n        (((bex * bex + bey * bey + bez * bez) * ((cez * daeps + dez * aceps + aez * cdeps) +\n        (ceztail * da3 + deztail * ac3 + aeztail * cd3)) + (dex * dex + dey * dey + dez * dez) *\n        ((aez * bceps - bez * aceps + cez * abeps) + (aeztail * bc3 - beztail * ac3 + ceztail * ab3))) -\n        ((aex * aex + aey * aey + aez * aez) * ((bez * cdeps - cez * bdeps + dez * bceps) +\n        (beztail * cd3 - ceztail * bd3 + deztail * bc3)) + (cex * cex + cey * cey + cez * cez) *\n        ((dez * abeps + aez * bdeps + bez * daeps) + (deztail * ab3 + aeztail * bd3 + beztail * da3)))) +\n        2 * (((bex * bextail + bey * beytail + bez * beztail) * (cez * da3 + dez * ac3 + aez * cd3) +\n        (dex * dextail + dey * deytail + dez * deztail) * (aez * bc3 - bez * ac3 + cez * ab3)) -\n        ((aex * aextail + aey * aeytail + aez * aeztail) * (bez * cd3 - cez * bd3 + dez * bc3) +\n        (cex * cextail + cey * ceytail + cez * ceztail) * (dez * ab3 + aez * bd3 + bez * da3)));\n\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    return insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez);\n}\n\nexport function insphere(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {\n    const aex = ax - ex;\n    const bex = bx - ex;\n    const cex = cx - ex;\n    const dex = dx - ex;\n    const aey = ay - ey;\n    const bey = by - ey;\n    const cey = cy - ey;\n    const dey = dy - ey;\n    const aez = az - ez;\n    const bez = bz - ez;\n    const cez = cz - ez;\n    const dez = dz - ez;\n\n    const aexbey = aex * bey;\n    const bexaey = bex * aey;\n    const ab = aexbey - bexaey;\n    const bexcey = bex * cey;\n    const cexbey = cex * bey;\n    const bc = bexcey - cexbey;\n    const cexdey = cex * dey;\n    const dexcey = dex * cey;\n    const cd = cexdey - dexcey;\n    const dexaey = dex * aey;\n    const aexdey = aex * dey;\n    const da = dexaey - aexdey;\n    const aexcey = aex * cey;\n    const cexaey = cex * aey;\n    const ac = aexcey - cexaey;\n    const bexdey = bex * dey;\n    const dexbey = dex * bey;\n    const bd = bexdey - dexbey;\n\n    const alift = aex * aex + aey * aey + aez * aez;\n    const blift = bex * bex + bey * bey + bez * bez;\n    const clift = cex * cex + cey * cey + cez * cez;\n    const dlift = dex * dex + dey * dey + dez * dez;\n\n    const det =\n        (clift * (dez * ab + aez * bd + bez * da) - dlift * (aez * bc - bez * ac + cez * ab)) +\n        (alift * (bez * cd - cez * bd + dez * bc) - blift * (cez * da + dez * ac + aez * cd));\n\n    const aezplus = Math.abs(aez);\n    const bezplus = Math.abs(bez);\n    const cezplus = Math.abs(cez);\n    const dezplus = Math.abs(dez);\n    const aexbeyplus = Math.abs(aexbey) + Math.abs(bexaey);\n    const bexceyplus = Math.abs(bexcey) + Math.abs(cexbey);\n    const cexdeyplus = Math.abs(cexdey) + Math.abs(dexcey);\n    const dexaeyplus = Math.abs(dexaey) + Math.abs(aexdey);\n    const aexceyplus = Math.abs(aexcey) + Math.abs(cexaey);\n    const bexdeyplus = Math.abs(bexdey) + Math.abs(dexbey);\n    const permanent =\n        (cexdeyplus * bezplus + bexdeyplus * cezplus + bexceyplus * dezplus) * alift +\n        (dexaeyplus * cezplus + aexceyplus * dezplus + cexdeyplus * aezplus) * blift +\n        (aexbeyplus * dezplus + bexdeyplus * aezplus + dexaeyplus * bezplus) * clift +\n        (bexceyplus * aezplus + aexceyplus * bezplus + aexbeyplus * cezplus) * dlift;\n\n    const errbound = isperrboundA * permanent;\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n    return -insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent);\n}\n\nexport function inspherefast(pax, pay, paz, pbx, pby, pbz, pcx, pcy, pcz, pdx, pdy, pdz, pex, pey, pez) {\n    const aex = pax - pex;\n    const bex = pbx - pex;\n    const cex = pcx - pex;\n    const dex = pdx - pex;\n    const aey = pay - pey;\n    const bey = pby - pey;\n    const cey = pcy - pey;\n    const dey = pdy - pey;\n    const aez = paz - pez;\n    const bez = pbz - pez;\n    const cez = pcz - pez;\n    const dez = pdz - pez;\n\n    const ab = aex * bey - bex * aey;\n    const bc = bex * cey - cex * bey;\n    const cd = cex * dey - dex * cey;\n    const da = dex * aey - aex * dey;\n    const ac = aex * cey - cex * aey;\n    const bd = bex * dey - dex * bey;\n\n    const abc = aez * bc - bez * ac + cez * ab;\n    const bcd = bez * cd - cez * bd + dez * bc;\n    const cda = cez * da + dez * ac + aez * cd;\n    const dab = dez * ab + aez * bd + bez * da;\n\n    const alift = aex * aex + aey * aey + aez * aez;\n    const blift = bex * bex + bey * bey + bez * bez;\n    const clift = cex * cex + cey * cey + cez * cez;\n    const dlift = dex * dex + dey * dey + dez * dez;\n\n    return (clift * dab - dlift * abc) + (alift * bcd - blift * cda);\n}\n","\nexport {orient2d, orient2dfast} from './esm/orient2d.js';\nexport {orient3d, orient3dfast} from './esm/orient3d.js';\nexport {incircle, incirclefast} from './esm/incircle.js';\nexport {insphere, inspherefast} from './esm/insphere.js';\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the center of\n        // the diagram <bx, by>, defined as the hulls barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n"],"names":["identity","x","translateX","translateY","y","entering","__axis","axis","orient","scale","tickArguments","tickValues","tickFormat","tickSizeInner","tickSizeOuter","tickPadding","offset","window","devicePixelRatio","k","transform","context","values","ticks","apply","domain","format","spacing","Math","max","range","range0","range1","length","position","bandwidth","round","d","copy","selection","path","selectAll","data","tick","order","tickExit","exit","tickEnter","enter","append","attr","line","select","text","merge","insert","transition","isFinite","getAttribute","p","parentNode","remove","filter","each","_","arguments","Array","from","slice","tickSize","axisRight","axisBottom","axisLeft","util_resulterrbound","util_sum","elen","e","flen","f","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","n","Float64Array","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2d","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","abs","orient2dadapt","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","util_splitter","util_estimate","i","errbound","C1len","C2len","Dlen","EDGE_STACK","Uint32Array","Delaunator","points","getX","defaultGetX","getY","defaultGetY","coords","constructor","maxTriangles","_triangles","_halfedges","Int32Array","_hashSize","ceil","sqrt","_hullPrev","_hullNext","_hullTri","_hullHash","_ids","_dists","update","i0","i1","i2","hullPrev","hullNext","hullTri","hullHash","minX","Infinity","minY","maxX","maxY","minDist","dist","i0x","i0y","i1x","i1y","minRadius","r","circumradius","dx","dy","ex","ey","bl","cl","i2x","i2y","quicksort","hull","j","d0","id","subarray","triangles","halfedges","center","circumcenter","_cx","_cy","_hullStart","hullSize","fill","_hashKey","trianglesLen","_addTriangle","xp","yp","start","key","q","t","_legalize","floor","pseudoAngle","a","ar","b","a0","b0","al","p0","pr","pl","p1","inCircle","px","py","fx","fy","bp","cp","ap","hbl","_link","br","ids","dists","left","right","temp","tempDist","median","swap","arr","tmp","Path","_x0","_y0","_x1","_y1","moveTo","closePath","lineTo","arc","x0","y0","rect","w","value","Polygon","push","Voronoi","delaunay","xmin","ymin","xmax","ymax","_circumcenters","vectors","_init","circumcenters","t2","t3","x1","y1","x2","y2","x3","y3","ab","undefined","sign","render","buffer","inedges","ti","tj","xi","yi","xj","yj","_renderSegment","h0","h1","v","_project","renderBounds","renderCell","_clip","cellPolygons","cell","cellPolygon","index","polygon","S","c0","_regioncode","c1","_clipSegment","contains","_step","neighbors","ci","cj","loop","ai","li","aj","lj","_cell","e0","V","_simplify","_clipInfinite","_clipFinite","P","e1","sx0","sy0","sx1","sy1","_edgecode","_edge","flip","vx0","vy0","vxn","vyn","unshift","splice","vx","vy","tau","PI","pow","pointX","pointY","Delaunay","that","flatArray","array","call","flatIterable","_delaunator","_hullIndex","collinear","cross","sort","bounds","hypot","sin","cos","hullIndex","voronoi","l","indexOf","find","dc","dt","renderHull","renderPoints","hullPolygon","renderTriangle","trianglePolygons","trianglePolygon"],"sourceRoot":""}