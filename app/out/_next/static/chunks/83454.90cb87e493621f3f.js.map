{"version":3,"file":"static/chunks/83454.90cb87e493621f3f.js","mappings":"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","sources":["webpack://_N_E/./charts/shared/annotation-circle.tsx","webpack://_N_E/./charts/shared/annotation-utils.ts","webpack://_N_E/./charts/shared/annotation-tooltip.tsx","webpack://_N_E/./charts/shared/annotations.tsx","webpack://_N_E/./charts/shared/interaction/hover-annotation-dot.tsx","webpack://_N_E/./charts/shared/interaction/tooltip-content.tsx","webpack://_N_E/./charts/shared/interaction/tooltip.tsx","webpack://_N_E/./charts/shared/use-annotation-interactions.ts"],"sourcesContent":["import { ButtonBase, Theme } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport clsx from \"clsx\";\n\nimport {\n  ANNOTATION_FOCUS_COLOR,\n  ANNOTATION_FOCUS_WIDTH,\n} from \"@/charts/shared/rendering-utils\";\n\nexport const AnnotationCircle = ({\n  x,\n  y,\n  color = DEFAULT_ANNOTATION_CIRCLE_COLOR,\n  focused = false,\n  onClick,\n}: {\n  x: number;\n  y: number;\n  color?: string;\n  focused?: boolean;\n  onClick?: () => void;\n}) => {\n  const classes = useStyles();\n\n  return (\n    <ButtonBase\n      className={clsx(classes.wrapper, onClick && classes.clickable)}\n      style={{ left: x, top: y, pointerEvents: onClick ? \"auto\" : \"none\" }}\n      onClick={onClick}\n    >\n      <div className={clsx(classes.outerCircle, focused && classes.focused)}>\n        <div\n          className={classes.innerCircle}\n          style={{ backgroundColor: color }}\n        />\n      </div>\n    </ButtonBase>\n  );\n};\n\nexport const DEFAULT_ANNOTATION_CIRCLE_COLOR = \"#1F2937\";\nconst SIZE = 16;\n\nconst useStyles = makeStyles((theme: Theme) => ({\n  wrapper: {\n    transform: \"translate3d(-50%, -50%, 0)\",\n    position: \"absolute\",\n    padding: theme.spacing(1),\n  },\n  outerCircle: {\n    width: SIZE,\n    height: SIZE,\n    borderRadius: \"50%\",\n    backgroundColor: theme.palette.background.paper,\n    boxShadow: theme.shadows[2],\n  },\n  innerCircle: {\n    transform: \"translate3d(-50%, -50%, 0)\",\n    position: \"absolute\",\n    left: \"50%\",\n    top: \"50%\",\n    width: SIZE / 2,\n    height: SIZE / 2,\n    borderRadius: \"50%\",\n  },\n  clickable: {\n    cursor: \"pointer\",\n  },\n  focused: {\n    outline: `${ANNOTATION_FOCUS_WIDTH}px solid ${ANNOTATION_FOCUS_COLOR}`,\n  },\n}));\n","import { useCallback } from \"react\";\n\nimport { useInteraction } from \"@/charts/shared/use-interaction\";\nimport {\n  Annotation,\n  AnnotationTarget,\n  ChartConfig,\n  Filters,\n  isSegmentInConfig,\n} from \"@/config-types\";\nimport { extractSingleFilters, getChartConfig } from \"@/config-utils\";\nimport { isAnnotationField } from \"@/configurator/components/chart-annotations/utils\";\nimport {\n  isConfiguring,\n  useConfiguratorState,\n} from \"@/configurator/configurator-state\";\nimport { FIELD_VALUE_NONE } from \"@/configurator/constants\";\nimport { Observation } from \"@/domain/data\";\n\nexport const useIsEditingAnnotation = () => {\n  const [state] = useConfiguratorState();\n  const { activeField } = getChartConfig(state);\n\n  return isAnnotationField(activeField) && isConfiguring(state);\n};\n\nexport const useGetAnnotationRenderState = () => {\n  const [interaction] = useInteraction();\n  const [state] = useConfiguratorState();\n  const chartConfig = getChartConfig(state);\n  const { activeField } = chartConfig;\n  const isEditing = useIsEditingAnnotation();\n\n  const getAnnotationRenderState = useCallback(\n    (\n      observation: Observation,\n      {\n        axisComponentId,\n        axisValue,\n      }: {\n        axisComponentId: string;\n        axisValue: string;\n      }\n    ) => {\n      let annotation: Annotation | undefined;\n\n      for (const a of chartConfig.annotations) {\n        const matches = matchesAnnotationTarget(observation, a.targets);\n\n        if (matches) {\n          annotation = a;\n          break;\n        }\n      }\n\n      let color: string | undefined;\n\n      if (annotation?.color && annotation.highlightType === \"filled\") {\n        color = annotation.color;\n      }\n\n      const currentInteraction = interaction;\n      const interactionMatches =\n        currentInteraction.type === \"annotation\" &&\n        currentInteraction.visible &&\n        currentInteraction.observation?.[`${axisComponentId}/__iri__`] ===\n          axisValue;\n\n      const targetsOtherAnnotations = chartConfig.annotations.some(\n        (a) =>\n          a.key !== activeField &&\n          matchesAnnotationTarget(observation, a.targets)\n      );\n      const isActive = annotation?.key === activeField;\n\n      let focused =\n        isEditing &&\n        ((interactionMatches && !targetsOtherAnnotations) || isActive);\n\n      return {\n        color,\n        focused,\n        isActive,\n      };\n    },\n    [activeField, chartConfig.annotations, interaction, isEditing]\n  );\n\n  return getAnnotationRenderState;\n};\n\nexport const getAnnotationTargetsFromObservation = (\n  observation: Observation,\n  {\n    chartConfig,\n    definitiveFilters,\n    segment,\n  }: {\n    chartConfig: ChartConfig;\n    definitiveFilters: Filters;\n    /** This is needed for stacked charts, where the segment value is not in the observation,\n     *  but in the getSegment function.\n     */\n    segment?: string;\n  }\n): Annotation[\"targets\"] => {\n  const singleFilters = extractSingleFilters(definitiveFilters);\n  const targets: Annotation[\"targets\"] = Object.entries(singleFilters)\n    .filter(([, v]) => v.value !== FIELD_VALUE_NONE)\n    .map(([componentId, value]) => ({\n      componentId,\n      value: `${value.value}`,\n    }));\n\n  switch (chartConfig.chartType) {\n    case \"column\":\n    case \"line\":\n    case \"area\": {\n      const xComponentId = chartConfig.fields.x.componentId;\n      if (xComponentId) {\n        targets.push({\n          componentId: xComponentId,\n          value: `${observation[`${xComponentId}/__iri__`]}`,\n        });\n      }\n\n      const segmentComponentId = chartConfig.fields.segment?.componentId;\n      if (segmentComponentId && segment) {\n        const value =\n          segment ?? observation[`${segmentComponentId}/__iri__`] ?? \"\";\n        targets.push({\n          componentId: segmentComponentId,\n          value,\n        });\n      }\n\n      break;\n    }\n    case \"bar\": {\n      const yComponentId = chartConfig.fields.y.componentId;\n      if (yComponentId) {\n        targets.push({\n          componentId: yComponentId,\n          value: `${observation[`${yComponentId}/__iri__`]}`,\n        });\n      }\n\n      const segmentComponentId = chartConfig.fields.segment?.componentId;\n      if (segmentComponentId && segment) {\n        const value =\n          segment ?? observation[`${segmentComponentId}/__iri__`] ?? \"\";\n        targets.push({\n          componentId: segmentComponentId,\n          value,\n        });\n      }\n\n      break;\n    }\n    case \"scatterplot\": {\n      const segmentComponentId = chartConfig.fields.segment?.componentId;\n      if (segmentComponentId && segment) {\n        const value =\n          segment ?? observation[`${segmentComponentId}/__iri__`] ?? \"\";\n        targets.push({\n          componentId: segmentComponentId,\n          value,\n        });\n      }\n\n      break;\n    }\n    case \"pie\": {\n      const segmentComponentId = chartConfig.fields.segment?.componentId;\n      if (segmentComponentId && segment) {\n        const value =\n          segment ?? observation[`${segmentComponentId}/__iri__`] ?? \"\";\n        targets.push({\n          componentId: segmentComponentId,\n          value,\n        });\n      }\n\n      break;\n    }\n    case \"comboLineColumn\":\n    case \"comboLineDual\":\n    case \"comboLineSingle\":\n    case \"map\":\n    case \"table\":\n      break;\n    default:\n      const _exhaustiveCheck: never = chartConfig;\n      return _exhaustiveCheck;\n  }\n\n  return targets;\n};\n\nexport const matchesAnnotationTarget = (\n  observation: Observation,\n  targets: AnnotationTarget[]\n) => {\n  if (targets.length === 0) {\n    return false;\n  }\n\n  for (const target of targets) {\n    const observationValue = observation[`${target.componentId}/__iri__`];\n\n    if (observationValue !== target.value) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const hasSegmentAnnotation = (\n  observation: Observation,\n  segment: string,\n  chartConfig: ChartConfig,\n  definitiveFilters: Filters\n) => {\n  if (!isSegmentInConfig(chartConfig)) {\n    return false;\n  }\n\n  const segmentComponentId = chartConfig.fields.segment?.componentId;\n  if (!segmentComponentId) {\n    return false;\n  }\n\n  return chartConfig.annotations.some((annotation) => {\n    const observationTargets = getAnnotationTargetsFromObservation(\n      observation,\n      {\n        chartConfig,\n        definitiveFilters,\n        segment,\n      }\n    );\n\n    if (annotation.targets.length === 0 || observationTargets.length === 0) {\n      return false;\n    }\n\n    const relevantAnnotationTargets = annotation.targets.filter(\n      (annotationTarget) => {\n        return observationTargets.some((observationTarget) => {\n          return annotationTarget.componentId === observationTarget.componentId;\n        });\n      }\n    );\n\n    if (relevantAnnotationTargets.length === 0) {\n      return false;\n    }\n\n    return relevantAnnotationTargets.every((annotationTarget) => {\n      return observationTargets.some((observationTarget) => {\n        return (\n          annotationTarget.componentId === observationTarget.componentId &&\n          annotationTarget.value === observationTarget.value\n        );\n      });\n    });\n  });\n};\n","import { IconButton, Theme, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useCallback, useLayoutEffect, useMemo, useRef, useState } from \"react\";\n\nimport { DEFAULT_ANNOTATION_CIRCLE_COLOR } from \"@/charts/shared/annotation-circle\";\nimport {\n  AnnotationEnabledChartState,\n  RenderAnnotation,\n} from \"@/charts/shared/annotations\";\nimport { useChartState } from \"@/charts/shared/chart-state\";\nimport { MarkdownInheritFonts } from \"@/components/markdown\";\nimport { Icon } from \"@/icons\";\nimport { useLocale } from \"@/locales/use-locale\";\nimport { useChartInteractiveFilters } from \"@/stores/interactive-filters\";\nimport { getTextSize } from \"@/utils/get-text-size\";\n\nexport const AnnotationTooltip = ({\n  renderAnnotation: { annotation, x, y },\n  closable,\n}: {\n  renderAnnotation: RenderAnnotation;\n  closable: boolean;\n}) => {\n  const locale = useLocale();\n  const classes = useStyles();\n  const annotations = useChartInteractiveFilters((d) => d.annotations);\n  const updateAnnotation = useChartInteractiveFilters(\n    (d) => d.updateAnnotation\n  );\n\n  const open = annotations[annotation.key];\n  const text = annotation.text[locale];\n\n  const ref = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    minWidth: 0,\n    height: 0,\n  });\n\n  useLayoutEffect(() => {\n    const { width: minWidth } = getTextSize(text, {\n      fontSize: 12,\n      width: 240,\n      fontWeight: 400,\n    });\n\n    if (ref.current && open) {\n      const rect = ref.current.getBoundingClientRect();\n      setDimensions({\n        width: rect.width,\n        minWidth,\n        height: rect.height,\n      });\n    }\n  }, [open, text]);\n\n  const {\n    bounds: { width },\n  } = useChartState() as AnnotationEnabledChartState;\n\n  const { left, top } = useMemo(() => {\n    return getAdjustedPosition({\n      x,\n      y,\n      minWidth: dimensions.minWidth,\n      chartWidth: width,\n    });\n  }, [x, y, dimensions, width]);\n\n  const handleClose = useCallback(() => {\n    updateAnnotation(annotation.key, false);\n  }, [annotation.key, updateAnnotation]);\n\n  return open && text ? (\n    <>\n      <Connector annotationX={x} annotationY={y} />\n      <div\n        ref={ref}\n        className={classes.root}\n        style={{ left, top, minWidth: dimensions.minWidth }}\n      >\n        <Typography className={classes.text} variant=\"caption\">\n          <MarkdownInheritFonts>{annotation.text[locale]}</MarkdownInheritFonts>\n        </Typography>\n        <IconButton\n          className={classes.closeButton}\n          onClick={handleClose}\n          disabled={!closable}\n        >\n          <Icon name=\"close\" size={14} />\n        </IconButton>\n      </div>\n    </>\n  ) : null;\n};\n\nconst Y_OFFSET = 12;\n\nconst getAdjustedPosition = ({\n  x,\n  y,\n  minWidth,\n  chartWidth,\n}: {\n  x: number;\n  y: number;\n  minWidth: number;\n  chartWidth: number;\n}) => {\n  const xOffset = -24;\n\n  let adjustedX = x + xOffset;\n  let adjustedY = y - Y_OFFSET;\n\n  if (adjustedX + minWidth > chartWidth) {\n    adjustedX = chartWidth - minWidth;\n  }\n\n  if (adjustedX < 0) {\n    adjustedX = 0;\n  }\n\n  return {\n    left: adjustedX,\n    top: adjustedY,\n  };\n};\n\nconst Connector = ({\n  annotationX,\n  annotationY,\n}: {\n  annotationX: number;\n  annotationY: number;\n}) => {\n  const classes = useStyles();\n  const connectorHeight = Y_OFFSET;\n  const connectorTop = annotationY - Y_OFFSET;\n\n  return (\n    <div\n      className={classes.connector}\n      style={{\n        left: annotationX,\n        top: connectorTop,\n        height: connectorHeight,\n      }}\n    />\n  );\n};\n\nconst useStyles = makeStyles((theme: Theme) => ({\n  root: {\n    zIndex: 2,\n    transform: \"translate(0%, -100%)\",\n    position: \"absolute\",\n    display: \"flex\",\n    alignItems: \"flex-start\",\n    justifyContent: \"space-between\",\n    gap: theme.spacing(2),\n    width: \"fit-content\",\n    maxWidth: 240,\n    padding: theme.spacing(3),\n    borderRadius: theme.shape.borderRadius,\n    backgroundColor: theme.palette.background.paper,\n    wordBreak: \"break-word\",\n    boxShadow: theme.shadows[4],\n  },\n  text: {\n    margin: \"auto 0\",\n  },\n  closeButton: {\n    transform: \"translate(25%, 0)\",\n    marginTop: `-${theme.spacing(2)}`,\n    padding: theme.spacing(1),\n    color: theme.palette.text.primary,\n  },\n  connector: {\n    zIndex: 1,\n    transform: \"translateX(-50%)\",\n    position: \"absolute\",\n    width: 1,\n    backgroundColor: DEFAULT_ANNOTATION_CIRCLE_COLOR,\n    pointerEvents: \"none\",\n  },\n}));\n","import { useCallback, useEffect, useMemo, useRef } from \"react\";\n\nimport { AreasState } from \"@/charts/area/areas-state\";\nimport { StackedBarsState } from \"@/charts/bar/bars-stacked-state\";\nimport { BarsState } from \"@/charts/bar/bars-state\";\nimport { StackedColumnsState } from \"@/charts/column/columns-stacked-state\";\nimport { ColumnsState } from \"@/charts/column/columns-state\";\nimport { LinesState } from \"@/charts/line/lines-state\";\nimport { PieState } from \"@/charts/pie/pie-state\";\nimport { ScatterplotState } from \"@/charts/scatterplot/scatterplot-state\";\nimport { AnnotationCircle } from \"@/charts/shared/annotation-circle\";\nimport { AnnotationTooltip } from \"@/charts/shared/annotation-tooltip\";\nimport {\n  matchesAnnotationTarget,\n  useIsEditingAnnotation,\n} from \"@/charts/shared/annotation-utils\";\nimport { useChartState } from \"@/charts/shared/chart-state\";\nimport { Annotation } from \"@/config-types\";\nimport { getChartConfig } from \"@/config-utils\";\nimport { isAnnotationField } from \"@/configurator/components/chart-annotations/utils\";\nimport { useConfiguratorState } from \"@/configurator/configurator-state\";\nimport { Observation } from \"@/domain/data\";\nimport { truthy } from \"@/domain/types\";\nimport { useLocale } from \"@/locales/use-locale\";\nimport { useChartInteractiveFilters } from \"@/stores/interactive-filters\";\n\nexport type AnnotationEnabledChartState =\n  | AreasState\n  | BarsState\n  | StackedBarsState\n  | ColumnsState\n  | StackedColumnsState\n  | LinesState\n  | PieState\n  | ScatterplotState;\n\nexport type GetAnnotationInfo = (\n  observation: Observation,\n  props: {\n    segment: string;\n    focusingSegment: boolean;\n  }\n) => {\n  x: number;\n  y: number;\n  color?: string;\n};\n\nexport const Annotations = () => {\n  const locale = useLocale();\n  const [state] = useConfiguratorState();\n  const chartConfig = getChartConfig(state);\n  const { activeField, annotations } = chartConfig;\n  const {\n    chartData,\n    bounds: { width, height, margins },\n    segmentDimension,\n    getSegment,\n    getAnnotationInfo,\n  } = useChartState() as AnnotationEnabledChartState;\n  const isEditingAnnotation = useIsEditingAnnotation();\n  const interactiveAnnotations = useChartInteractiveFilters(\n    (d) => d.annotations\n  );\n  const updateAnnotation = useChartInteractiveFilters(\n    (d) => d.updateAnnotation\n  );\n  const hasAutoOpened = useRef<string | null>(null);\n  const previousActiveField = useRef<string | undefined>(activeField);\n\n  const handleAnnotationClick = useCallback(\n    (annotation: Annotation) => {\n      updateAnnotation(annotation.key, !interactiveAnnotations[annotation.key]);\n    },\n    [interactiveAnnotations, updateAnnotation]\n  );\n\n  const createRenderAnnotation: (\n    annotation: Annotation,\n    x: number,\n    y: number,\n    color: string | undefined,\n    focused: boolean\n  ) => RenderAnnotation = useCallback(\n    (annotation, x, y, color, focused) => ({\n      annotation,\n      x: x + margins.left,\n      y: y + margins.top,\n      color,\n      focused,\n    }),\n    [margins.left, margins.top]\n  );\n\n  const findObservationForAnnotation = useCallback(\n    (annotation: Annotation) => {\n      return chartData.find((observation) => {\n        return annotation.targets.some(\n          (target) =>\n            observation[`${target.componentId}/__iri__`] === target.value &&\n            target.componentId !== segmentDimension?.id\n        );\n      });\n    },\n    [chartData, segmentDimension?.id]\n  );\n\n  const processAnnotationWithoutSegmentFocus = useCallback(\n    (annotation: Annotation) => {\n      const observation = findObservationForAnnotation(annotation);\n\n      if (!observation) {\n        return;\n      }\n\n      const { x, y, color } = getAnnotationInfo(observation, {\n        segment: \"\",\n        focusingSegment: false,\n      });\n\n      const focused = isEditingAnnotation\n        ? activeField === annotation.key\n        : false;\n\n      return createRenderAnnotation(annotation, x, y, color, focused);\n    },\n    [\n      findObservationForAnnotation,\n      getAnnotationInfo,\n      isEditingAnnotation,\n      activeField,\n      createRenderAnnotation,\n    ]\n  );\n\n  const processAnnotationWithSegmentFocus = useCallback(\n    (annotation: Annotation) => {\n      const focused = isEditingAnnotation\n        ? activeField === annotation.key\n        : false;\n\n      return chartData.map((observation) => {\n        if (!matchesAnnotationTarget(observation, annotation.targets)) {\n          return;\n        }\n\n        const segment = getSegment(observation);\n        const { x, y, color } = getAnnotationInfo(observation, {\n          segment,\n          focusingSegment: true,\n        });\n\n        const finalColor =\n          color ??\n          (annotation.highlightType === \"filled\"\n            ? annotation.color\n            : undefined);\n\n        return createRenderAnnotation(annotation, x, y, finalColor, focused);\n      });\n    },\n    [\n      isEditingAnnotation,\n      activeField,\n      chartData,\n      getSegment,\n      getAnnotationInfo,\n      createRenderAnnotation,\n    ]\n  );\n\n  const renderAnnotations = useMemo(() => {\n    // A \"hack\" to prevent using // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    // We need to re-compute the annotation positions when the chart width or height changes.\n    width;\n    height;\n\n    if (annotations.length === 0) {\n      return [];\n    }\n\n    return annotations\n      .flatMap((annotation) => {\n        const focusingSegment =\n          !segmentDimension ||\n          annotation.targets.some(\n            (target) => target.componentId === segmentDimension.id\n          );\n\n        if (focusingSegment) {\n          return processAnnotationWithSegmentFocus(annotation);\n        }\n\n        return processAnnotationWithoutSegmentFocus(annotation);\n      })\n      .filter(truthy);\n  }, [\n    width,\n    height,\n    annotations,\n    segmentDimension,\n    processAnnotationWithSegmentFocus,\n    processAnnotationWithoutSegmentFocus,\n  ]);\n\n  useEffect(() => {\n    if (!isEditingAnnotation) {\n      hasAutoOpened.current = null;\n      return;\n    }\n\n    if (\n      activeField &&\n      !interactiveAnnotations[activeField] &&\n      hasAutoOpened.current !== activeField\n    ) {\n      updateAnnotation(activeField, true);\n      hasAutoOpened.current = activeField;\n    }\n  }, [\n    activeField,\n    interactiveAnnotations,\n    isEditingAnnotation,\n    updateAnnotation,\n  ]);\n\n  useEffect(() => {\n    const prevField = previousActiveField.current;\n\n    if (\n      prevField &&\n      isAnnotationField(prevField) &&\n      prevField !== activeField\n    ) {\n      const prevAnnotation = annotations.find((a) => a.key === prevField);\n\n      if (prevAnnotation && !prevAnnotation.defaultOpen) {\n        updateAnnotation(prevField, false);\n      }\n    }\n\n    previousActiveField.current = activeField;\n  }, [activeField, annotations, updateAnnotation]);\n\n  return (\n    <>\n      {renderAnnotations.map((renderAnnotation) => {\n        const { annotation, x, y, color, focused } = renderAnnotation;\n\n        return (\n          <>\n            {annotation.text[locale] || focused ? (\n              <AnnotationCircle\n                key={annotation.key}\n                x={x}\n                y={y}\n                color={color}\n                focused={focused}\n                onClick={() => handleAnnotationClick(annotation)}\n              />\n            ) : null}\n            <AnnotationTooltip\n              renderAnnotation={renderAnnotation}\n              closable={!isEditingAnnotation || annotation.key !== activeField}\n            />\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport type RenderAnnotation = {\n  annotation: Annotation;\n  x: number;\n  y: number;\n  color: string | undefined;\n  focused: boolean;\n};\n\nexport const ANNOTATION_SINGLE_SEGMENT_OFFSET = 12;\n","import { AreasState } from \"@/charts/area/areas-state\";\nimport { StackedBarsState } from \"@/charts/bar/bars-stacked-state\";\nimport { BarsState } from \"@/charts/bar/bars-state\";\nimport { StackedColumnsState } from \"@/charts/column/columns-stacked-state\";\nimport { ColumnsState } from \"@/charts/column/columns-state\";\nimport { LinesState } from \"@/charts/line/lines-state\";\nimport { PieState } from \"@/charts/pie/pie-state\";\nimport { ScatterplotState } from \"@/charts/scatterplot/scatterplot-state\";\nimport { AnnotationCircle } from \"@/charts/shared/annotation-circle\";\nimport { useChartState } from \"@/charts/shared/chart-state\";\nimport { useInteraction } from \"@/charts/shared/use-interaction\";\n\nexport const HoverAnnotationDot = () => {\n  const [interaction] = useInteraction();\n  const {\n    getAnnotationInfo,\n    bounds: { margins },\n  } = useChartState() as\n    | AreasState\n    | LinesState\n    | PieState\n    | ScatterplotState\n    | BarsState\n    | StackedBarsState\n    | ColumnsState\n    | StackedColumnsState;\n\n  if (\n    interaction.type !== \"annotation\" ||\n    !interaction.visible ||\n    !interaction.observation\n  ) {\n    return null;\n  }\n\n  const { x, y, color } = getAnnotationInfo(interaction.observation, {\n    segment: interaction.segment ?? \"\",\n    focusingSegment: !!interaction.focusingSegment,\n  });\n\n  return (\n    <AnnotationCircle\n      x={x + margins.left}\n      y={y + margins.top}\n      color={color}\n      focused\n    />\n  );\n};\n","import { Box, Typography } from \"@mui/material\";\n\nimport { TooltipValue } from \"@/charts/shared/interaction/tooltip\";\nimport { LegendItem } from \"@/charts/shared/legend-color\";\n\n// Generic\nexport const TooltipSingle = ({\n  xValue,\n  segment,\n  yValue,\n  yError,\n}: {\n  xValue?: string;\n  segment?: string;\n  yValue?: string;\n  yError?: string;\n}) => {\n  return (\n    <div>\n      {xValue && (\n        <Typography\n          component=\"div\"\n          variant=\"caption\"\n          sx={{ fontWeight: \"bold\", whiteSpace: \"wrap\" }}\n        >\n          {xValue}\n        </Typography>\n      )}\n      {segment && (\n        <Typography component=\"div\" variant=\"caption\">\n          {segment}\n        </Typography>\n      )}\n      {yValue && (\n        <Typography component=\"div\" variant=\"caption\">\n          {yValue}\n          {yError ?? null}\n        </Typography>\n      )}\n    </div>\n  );\n};\n\nexport const TooltipMultiple = ({\n  xValue,\n  segmentValues,\n}: {\n  xValue?: string;\n  segmentValues: TooltipValue[];\n}) => {\n  return (\n    <Box>\n      {xValue && (\n        <Typography\n          component=\"div\"\n          variant=\"caption\"\n          sx={{ fontWeight: \"bold\" }}\n        >\n          {xValue}\n        </Typography>\n      )}\n      {segmentValues.map((d, i) => (\n        <LegendItem\n          key={i}\n          label={`${d.label}: ${d.value}${d.error ?? \"\"}`}\n          color={d.color}\n          symbol={d.symbol ?? \"square\"}\n          smaller\n        />\n      ))}\n    </Box>\n  );\n};\n\n// Chart Specific\nexport const TooltipScatterplot = ({\n  firstLine,\n  secondLine,\n  thirdLine,\n}: {\n  firstLine?: string;\n  secondLine?: string;\n  thirdLine?: string;\n}) => {\n  return (\n    <Box>\n      {firstLine && (\n        <Typography\n          component=\"div\"\n          variant=\"caption\"\n          sx={{ fontWeight: \"bold\" }}\n        >\n          {firstLine}\n        </Typography>\n      )}\n      {secondLine && (\n        <Typography component=\"div\" variant=\"caption\">\n          {secondLine}\n        </Typography>\n      )}\n      {thirdLine && (\n        <Typography component=\"div\" variant=\"caption\">\n          {thirdLine}\n        </Typography>\n      )}\n    </Box>\n  );\n};\n","import { PieArcDatum } from \"d3-shape\";\nimport { ReactNode } from \"react\";\n\nimport { AreasState } from \"@/charts/area/areas-state\";\nimport { GroupedBarsState } from \"@/charts/bar/bars-grouped-state\";\nimport { StackedBarsState } from \"@/charts/bar/bars-stacked-state\";\nimport { BarsState } from \"@/charts/bar/bars-state\";\nimport { ComboLineColumnState } from \"@/charts/combo/combo-line-column-state\";\nimport { ComboLineDualState } from \"@/charts/combo/combo-line-dual-state\";\nimport { ComboLineSingleState } from \"@/charts/combo/combo-line-single-state\";\nimport { LinesState } from \"@/charts/line/lines-state\";\nimport { PieState } from \"@/charts/pie/pie-state\";\nimport { ScatterplotState } from \"@/charts/scatterplot/scatterplot-state\";\nimport { useChartState } from \"@/charts/shared/chart-state\";\nimport {\n  TooltipBox,\n  TooltipPlacement,\n} from \"@/charts/shared/interaction/tooltip-box\";\nimport {\n  TooltipMultiple,\n  TooltipSingle,\n} from \"@/charts/shared/interaction/tooltip-content\";\nimport { LegendSymbol } from \"@/charts/shared/legend-color\";\nimport { useInteraction } from \"@/charts/shared/use-interaction\";\nimport { Observation } from \"@/domain/data\";\n\nexport const Tooltip = ({ type = \"single\" }: { type: TooltipType }) => {\n  const [{ type: interactionType, visible, observation }] = useInteraction();\n\n  return interactionType === \"tooltip\" && visible && observation ? (\n    <TooltipInner d={observation} type={type} />\n  ) : null;\n};\nexport type { TooltipPlacement };\n\ntype TooltipType = \"single\" | \"multiple\";\n\nexport type TooltipValue = {\n  hide?: boolean;\n  label?: string;\n  value: string;\n  error?: string;\n  color: string;\n  symbol?: LegendSymbol;\n} & (\n  | {\n      axis: \"x\" | \"y\";\n      axisOffset: number;\n    }\n  | {\n      axis?: undefined;\n      axisOffset?: undefined;\n    }\n);\n\nexport type TooltipInfo = {\n  xAnchor: number;\n  yAnchor: number | undefined;\n  placement: TooltipPlacement;\n  value: string;\n  tooltipContent?: ReactNode;\n  datum: TooltipValue;\n  values: TooltipValue[] | undefined;\n  withTriangle?: boolean;\n};\n\nconst TooltipInner = ({ d, type }: { d: Observation; type: TooltipType }) => {\n  const { bounds, getTooltipInfo } = useChartState() as\n    | AreasState\n    | BarsState\n    | GroupedBarsState\n    | StackedBarsState\n    | ComboLineDualState\n    | ComboLineSingleState\n    | ComboLineColumnState\n    | LinesState\n    | PieState\n    | ScatterplotState;\n  const { margins } = bounds;\n  const {\n    xAnchor,\n    yAnchor,\n    placement,\n    value,\n    tooltipContent,\n    datum,\n    values,\n    withTriangle,\n  } = getTooltipInfo(d as Observation & PieArcDatum<Observation>);\n\n  if (Number.isNaN(yAnchor) || yAnchor === undefined) {\n    return null;\n  }\n\n  return (\n    <TooltipBox\n      x={xAnchor}\n      y={yAnchor}\n      placement={placement}\n      withTriangle={withTriangle}\n      margins={margins}\n    >\n      {tooltipContent ? (\n        tooltipContent\n      ) : type === \"multiple\" && values ? (\n        <TooltipMultiple xValue={value} segmentValues={values} />\n      ) : (\n        <TooltipSingle\n          xValue={value}\n          segment={datum.label}\n          yValue={datum.value}\n          yError={datum.error}\n        />\n      )}\n    </TooltipBox>\n  );\n};\n","import isEqual from \"lodash/isEqual\";\n\nimport {\n  getAnnotationTargetsFromObservation,\n  useIsEditingAnnotation,\n} from \"@/charts/shared/annotation-utils\";\nimport { useInteraction } from \"@/charts/shared/use-interaction\";\nimport { getChartConfig, useDefinitiveFilters } from \"@/config-utils\";\nimport { useConfiguratorState } from \"@/configurator/configurator-state\";\nimport { Observation } from \"@/domain/data\";\nimport { useEvent } from \"@/utils/use-event\";\n\nexport const useAnnotationInteractions = ({\n  focusingSegment,\n}: {\n  focusingSegment: boolean;\n}) => {\n  const [, dispatchInteraction] = useInteraction();\n  const [state, dispatch] = useConfiguratorState();\n  const chartConfig = getChartConfig(state);\n  const { activeField, annotations } = chartConfig;\n  const definitiveFilters = useDefinitiveFilters();\n  const isEditingAnnotation = useIsEditingAnnotation();\n  const activeAnnotation = annotations.find((a) => a.key === activeField);\n\n  const onClick = useEvent(\n    (observation: Observation, { segment }: { segment?: string }) => {\n      if (!isEditingAnnotation || !activeAnnotation || !activeField) {\n        return;\n      }\n\n      const activeNewTargets = getAnnotationTargetsFromObservation(\n        observation,\n        {\n          chartConfig,\n          definitiveFilters,\n          segment,\n        }\n      );\n\n      for (const annotation of annotations) {\n        const currentTargets = annotation.targets;\n        const newTargets =\n          annotation.key !== activeField\n            ? getAnnotationTargetsFromObservation(observation, {\n                chartConfig,\n                definitiveFilters,\n                segment,\n              })\n            : activeNewTargets;\n\n        if (isEqual(currentTargets, newTargets)) {\n          return;\n        }\n      }\n\n      dispatch({\n        type: \"CHART_ANNOTATION_TARGETS_CHANGE\",\n        value: {\n          key: activeField,\n          targets: activeNewTargets,\n        },\n      });\n    }\n  );\n\n  const onHover = useEvent(\n    (observation: Observation, { segment }: { segment?: string }) => {\n      dispatchInteraction({\n        type: \"INTERACTION_UPDATE\",\n        value: {\n          type: isEditingAnnotation ? \"annotation\" : \"tooltip\",\n          visible: true,\n          observation,\n          focusingSegment,\n          segment,\n        },\n      });\n    }\n  );\n\n  const onHoverOut = useEvent(() => {\n    dispatchInteraction({\n      type: \"INTERACTION_HIDE\",\n    });\n  });\n\n  return {\n    onClick,\n    onHover,\n    onHoverOut,\n  };\n};\n"],"names":["AnnotationCircle","_ref","x","y","color","DEFAULT_ANNOTATION_CIRCLE_COLOR","focused","onClick","classes","useStyles","_jsx","ButtonBase","className","clsx","wrapper","clickable","style","left","top","pointerEvents","children","outerCircle","innerCircle","backgroundColor","makeStyles","theme","transform","position","padding","spacing","width","height","borderRadius","palette","background","paper","boxShadow","shadows","SIZE","cursor","outline","ANNOTATION_FOCUS_WIDTH","ANNOTATION_FOCUS_COLOR","useIsEditingAnnotation","state","useConfiguratorState","activeField","getChartConfig","isAnnotationField","isConfiguring","useGetAnnotationRenderState","interaction","useInteraction","chartConfig","isEditing","useCallback","observation","annotation","axisComponentId","axisValue","a","annotations","matchesAnnotationTarget","targets","highlightType","interactionMatches","currentInteraction","type","visible","targetsOtherAnnotations","some","key","isActive","getAnnotationTargetsFromObservation","_ref2","definitiveFilters","segment","Object","entries","extractSingleFilters","filter","_ref3","v","value","FIELD_VALUE_NONE","map","_ref4","componentId","chartType","xComponentId","fields","push","segmentComponentId","yComponentId","length","target","observationValue","hasSegmentAnnotation","isSegmentInConfig","observationTargets","relevantAnnotationTargets","annotationTarget","observationTarget","every","AnnotationTooltip","renderAnnotation","closable","locale","useLocale","useChartInteractiveFilters","d","updateAnnotation","open","text","ref","useRef","dimensions","setDimensions","useState","minWidth","useLayoutEffect","getTextSize","fontSize","fontWeight","current","rect","getBoundingClientRect","bounds","useChartState","useMemo","getAdjustedPosition","chartWidth","handleClose","_jsxs","_Fragment","Connector","annotationX","annotationY","root","Typography","variant","MarkdownInheritFonts","IconButton","closeButton","disabled","Icon","name","size","adjustedX","connector","zIndex","display","alignItems","justifyContent","gap","maxWidth","shape","wordBreak","margin","marginTop","primary","Annotations","chartData","margins","segmentDimension","getSegment","getAnnotationInfo","isEditingAnnotation","interactiveAnnotations","hasAutoOpened","previousActiveField","handleAnnotationClick","createRenderAnnotation","findObservationForAnnotation","find","id","processAnnotationWithoutSegmentFocus","focusingSegment","processAnnotationWithSegmentFocus","finalColor","undefined","renderAnnotations","flatMap","truthy","useEffect","prevField","prevAnnotation","defaultOpen","ANNOTATION_SINGLE_SEGMENT_OFFSET","HoverAnnotationDot","TooltipSingle","xValue","yValue","yError","component","sx","whiteSpace","TooltipMultiple","segmentValues","Box","i","LegendItem","label","error","symbol","smaller","TooltipScatterplot","firstLine","secondLine","thirdLine","Tooltip","interactionType","TooltipInner","getTooltipInfo","xAnchor","yAnchor","placement","tooltipContent","datum","values","withTriangle","isNaN","TooltipBox","useAnnotationInteractions","dispatchInteraction","dispatch","useDefinitiveFilters","activeAnnotation","useEvent","activeNewTargets","currentTargets","newTargets","isEqual","onHover","onHoverOut"],"sourceRoot":""}