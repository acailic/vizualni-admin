{"version":3,"file":"static/chunks/87570.f57481207c4653fd.js","mappings":"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","sources":["webpack://_N_E/./charts/shared/axis-hide-overflow-rect.tsx","webpack://_N_E/./charts/shared/limits/rendering-utils.tsx","webpack://_N_E/./charts/shared/limits/create-component.tsx","webpack://_N_E/./charts/shared/margins.ts","webpack://_N_E/./charts/shared/render-value-labels.ts","webpack://_N_E/./charts/shared/show-values-utils.ts","webpack://_N_E/./charts/shared/use-chart-formatters.ts","webpack://_N_E/./utils/array.ts"],"sourcesContent":["import { useChartState } from \"@/charts/shared/chart-state\";\n\n/** Use to hide chart content overflowing below the X axis.\n * Can happen when user defined a custom domain for the axis. */\nexport const AxisHideXOverflowRect = () => {\n  const {\n    bounds: {\n      chartWidth,\n      chartHeight,\n      margins: { top, left, bottom },\n    },\n  } = useChartState();\n\n  return (\n    <rect\n      x={left - 1}\n      y={chartHeight + top}\n      width={chartWidth + 2}\n      height={bottom}\n      fill=\"white\"\n    />\n  );\n};\n\n/** Use to hide chart content overflowing below the X axis.\n * Can happen when user defined a custom domain for the axis. */\nexport const AxisHideYOverflowRect = () => {\n  const {\n    bounds: {\n      chartHeight,\n      margins: { top, left },\n    },\n  } = useChartState();\n\n  return (\n    <rect\n      x={0}\n      y={top - 1}\n      width={left}\n      height={chartHeight + 2}\n      fill=\"white\"\n    />\n  );\n};\n","import { Bounds } from \"@/charts/shared/use-size\";\nimport { type Limit } from \"@/config-types\";\n\nexport type RenderLimitDatum = {\n  key: string;\n  x1: number;\n  x2: number;\n  y1: number;\n  y2: number;\n  size: number;\n  fill: string;\n  lineType: Limit[\"lineType\"];\n  symbolType?: Limit[\"symbolType\"];\n};\n\nexport const Limits = ({\n  renderData,\n  margins,\n  isHorizontal,\n}: {\n  renderData: RenderLimitDatum[];\n  margins: Bounds[\"margins\"];\n  isHorizontal?: boolean;\n}) => {\n  return (\n    <g\n      id={isHorizontal ? \"horizontal-limits\" : \"vertical-limits\"}\n      transform={`translate(${margins.left}, ${margins.top})`}\n    >\n      <g>\n        {renderData.map((limit) => (\n          <g key={limit.key}>\n            <MiddleLine limit={limit} />\n            {limit.symbolType ? (\n              <g className=\"symbol\">\n                <LimitSymbol limit={limit} />\n              </g>\n            ) : (\n              <LimitLines limit={limit} isHorizontal={isHorizontal} />\n            )}\n          </g>\n        ))}\n      </g>\n    </g>\n  );\n};\n\nconst LIMIT_SIZE = 3;\n\nconst MiddleLine = ({ limit }: { limit: RenderLimitDatum }) => {\n  return (\n    <line\n      className=\"middle-line\"\n      x1={limit.x1}\n      x2={limit.x2}\n      y1={limit.y1}\n      y2={limit.y2}\n      stroke={limit.fill}\n      strokeWidth={LIMIT_SIZE}\n      strokeDasharray={limit.lineType === \"dashed\" ? \"3 3\" : \"none\"}\n    />\n  );\n};\n\ntype SymbolProps = {\n  cx: number;\n  cy: number;\n  fill: string;\n};\n\nconst LimitSymbol = ({ limit }: { limit: RenderLimitDatum }) => {\n  if (!limit.symbolType) {\n    return null;\n  }\n\n  const cx = (limit.x1 + limit.x2) / 2;\n  const cy = (limit.y1 + limit.y2) / 2;\n  const props: SymbolProps = {\n    cx,\n    cy,\n    fill: limit.fill,\n  };\n\n  switch (limit.symbolType) {\n    case \"circle\":\n      return <CircleSymbol {...props} />;\n    case \"cross\":\n      return <CrossSymbol {...props} />;\n    case \"triangle\":\n      return <TriangleSymbol {...props} />;\n    default:\n      const _exhaustiveCheck: never = limit.symbolType;\n      return _exhaustiveCheck;\n  }\n};\n\nconst CircleSymbol = ({ cx, cy, fill }: SymbolProps) => {\n  return <circle cx={cx} cy={cy} r={LIMIT_SIZE * 1.5} fill={fill} />;\n};\n\nconst CrossSymbol = ({ cx, cy, fill }: SymbolProps) => {\n  return (\n    <>\n      <CrossSymbolArm cx={cx} cy={cy} fill={fill} rotation={45} />\n      <CrossSymbolArm cx={cx} cy={cy} fill={fill} rotation={-45} />\n    </>\n  );\n};\n\nconst CrossSymbolArm = ({\n  cx,\n  cy,\n  fill,\n  rotation,\n}: SymbolProps & { rotation: number }) => {\n  const armWidth = LIMIT_SIZE * 4;\n\n  return (\n    <rect\n      x={cx - armWidth / 2}\n      y={cy - LIMIT_SIZE / 2}\n      width={armWidth}\n      height={LIMIT_SIZE}\n      fill={fill}\n      style={{\n        transform: `rotate(${rotation}deg)`,\n        transformBox: \"fill-box\",\n        transformOrigin: \"center\",\n      }}\n    />\n  );\n};\n\nconst TriangleSymbol = ({ cx, cy, fill }: SymbolProps) => {\n  return (\n    <path\n      d=\"M0,-2.5L2.2,2.5L-2.2,2.5Z\"\n      fill={fill}\n      transform={`translate(${cx}, ${cy}) scale(2)`}\n    />\n  );\n};\n\nconst LimitLines = ({\n  limit,\n  isHorizontal,\n}: {\n  limit: RenderLimitDatum;\n  isHorizontal?: boolean;\n}) => {\n  return (\n    <>\n      <LimitLine type=\"top\" limit={limit} isHorizontal={isHorizontal} />\n      <LimitLine type=\"bottom\" limit={limit} isHorizontal={isHorizontal} />\n    </>\n  );\n};\n\nconst LimitLine = ({\n  type,\n  limit,\n  isHorizontal,\n}: {\n  type: \"top\" | \"bottom\";\n  limit: RenderLimitDatum;\n  isHorizontal?: boolean;\n}) => {\n  const isRange = isHorizontal ? limit.x1 !== limit.x2 : limit.y1 !== limit.y2;\n  const props = isHorizontal\n    ? {\n        x1: type === \"top\" ? limit.x2 : limit.x1,\n        x2: type === \"top\" ? limit.x2 : limit.x1,\n        y1: limit.y1 + limit.size / 2,\n        y2: limit.y2 - limit.size / 2,\n      }\n    : {\n        y1: type === \"top\" ? limit.y2 : limit.y1,\n        y2: type === \"top\" ? limit.y2 : limit.y1,\n        x1: limit.x1 + limit.size / 2,\n        x2: limit.x2 - limit.size / 2,\n      };\n\n  return (\n    <line\n      {...props}\n      className={`${type}-line`}\n      stroke={limit.fill}\n      strokeWidth={LIMIT_SIZE}\n      strokeDasharray={isRange || limit.lineType === \"solid\" ? \"none\" : \"3 3\"}\n    />\n  );\n};\n","import { useMemo } from \"react\";\n\nimport {\n  NumericalValueGetter,\n  StringValueGetter,\n  TemporalValueGetter,\n} from \"@/charts/shared/chart-state\";\nimport { HorizontalChartState } from \"@/charts/shared/limits/horizontal\";\nimport {\n  Limits,\n  RenderLimitDatum,\n} from \"@/charts/shared/limits/rendering-utils\";\nimport { VerticalChartState } from \"@/charts/shared/limits/vertical\";\nimport { useLimits } from \"@/config-utils\";\nimport { Limit } from \"@/rdf/limits\";\n\nexport const createLimitsComponent = <\n  T extends VerticalChartState | HorizontalChartState,\n>({\n  isHorizontal,\n  getChartState,\n}: {\n  isHorizontal: boolean;\n  getChartState: () => T;\n}) => {\n  const Component = ({\n    axisDimension,\n    limits,\n  }: ReturnType<typeof useLimits>) => {\n    const {\n      bounds: { margins, chartWidth, chartHeight },\n      xScale,\n      yScale,\n      getX,\n      getY,\n    } = getChartState();\n\n    const getAxisValue = isHorizontal ? getY : getX;\n    const axisDimensionScale = isHorizontal ? yScale : xScale;\n    const measureScale = isHorizontal ? xScale : yScale;\n    const chartSize = isHorizontal ? chartHeight : chartWidth;\n\n    const renderData = useMemo(() => {\n      if (!limits.length) {\n        return [];\n      }\n\n      const isBandScale = \"bandwidth\" in axisDimensionScale;\n      const limitSize = isBandScale ? axisDimensionScale.bandwidth() : 15;\n\n      return limits.flatMap(\n        ({ configLimit, measureLimit, relatedAxisDimensionValueLabel }) => {\n          const observationKey = axisDimension?.id ?? \"\";\n          const observationLabel = relatedAxisDimensionValueLabel ?? \"\";\n          const { axis1Value, axis2Value, measure1Value, measure2Value } =\n            getLimitValues({\n              measureLimit,\n              getAxisValue,\n              observationKey,\n              observationLabel,\n              axisDimensionId: axisDimension?.id,\n            });\n          const axis1 = axisDimensionScale(axis1Value);\n          const axis2 = axisDimensionScale(axis2Value);\n          const measure1 = measureScale(measure1Value);\n          const measure2 = measureScale(measure2Value);\n          const key = configLimit.related\n            .map((d) => d.dimensionId + d.value)\n            .join();\n          const size =\n            axis1 === undefined\n              ? chartSize\n              : measureLimit.type === \"time-range\"\n                ? 0\n                : limitSize;\n          const axisOffset = isBandScale ? size / 2 : 0;\n          const hasValidAxis = axis1 !== undefined && axis2 !== undefined;\n          const hasNoAxis = relatedAxisDimensionValueLabel === undefined;\n          let x1: number;\n          let x2: number;\n          let y1: number;\n          let y2: number;\n\n          if (isHorizontal) {\n            y1 = axis1 ? axis1 + axisOffset : 0;\n            y2 = axis2 ? axis2 + axisOffset : chartSize;\n            x1 = measure1 ?? 0;\n            x2 = measure2 ?? 0;\n          } else {\n            x1 = axis1 ? axis1 + axisOffset : 0;\n            x2 = axis2 ? axis2 + axisOffset : chartSize;\n            y1 = measure1 ?? 0;\n            y2 = measure2 ?? 0;\n          }\n\n          const datum = {\n            key,\n            x1,\n            x2,\n            y1,\n            y2,\n            size,\n            fill: configLimit.color,\n            lineType: configLimit.lineType,\n            symbolType: configLimit.symbolType,\n          } satisfies RenderLimitDatum;\n\n          return hasValidAxis || hasNoAxis ? [datum] : [];\n        }\n      );\n    }, [\n      limits,\n      axisDimension?.id,\n      getAxisValue,\n      axisDimensionScale,\n      measureScale,\n      chartSize,\n    ]);\n\n    return (\n      <Limits\n        renderData={renderData}\n        margins={margins}\n        isHorizontal={isHorizontal}\n      />\n    );\n  };\n\n  Component.displayName = isHorizontal\n    ? \"HorizontalLimitsInner\"\n    : \"VerticalLimitsInner\";\n\n  return Component;\n};\n\nconst getLimitValues = ({\n  measureLimit,\n  getAxisValue,\n  observationKey,\n  observationLabel,\n  axisDimensionId,\n}: {\n  measureLimit: Limit;\n  getAxisValue: NumericalValueGetter | StringValueGetter | TemporalValueGetter;\n  observationKey: string;\n  observationLabel: string;\n  axisDimensionId?: string;\n}) => {\n  let axis1Value: $IntentionalAny;\n  let axis2Value: $IntentionalAny;\n  let measure1Value: $IntentionalAny;\n  let measure2Value: $IntentionalAny;\n\n  switch (measureLimit.type) {\n    case \"single\": {\n      axis1Value = axis2Value = getAxisValue({\n        [observationKey]: observationLabel,\n      });\n      measure1Value = measure2Value = measureLimit.value;\n      break;\n    }\n    case \"value-range\": {\n      axis1Value = axis2Value = getAxisValue({\n        [observationKey]: observationLabel,\n      });\n      measure1Value = measureLimit.min;\n      measure2Value = measureLimit.max;\n      break;\n    }\n    case \"time-range\": {\n      const { related } = measureLimit;\n      const timeFrom =\n        related.find(\n          (d) => d.type === \"time-from\" && d.dimensionId === axisDimensionId\n        )?.label ?? \"\";\n      const timeTo =\n        related.find(\n          (d) => d.type === \"time-to\" && d.dimensionId === axisDimensionId\n        )?.label ?? \"\";\n      axis1Value = getAxisValue({ [observationKey]: timeFrom });\n      axis2Value = getAxisValue({ [observationKey]: timeTo });\n      measure1Value = measure2Value = measureLimit.value;\n      break;\n    }\n    default: {\n      const _exhaustiveCheck: never = measureLimit;\n      return _exhaustiveCheck;\n    }\n  }\n\n  return {\n    axis1Value,\n    axis2Value,\n    measure1Value,\n    measure2Value,\n  };\n};\n","export const DEFAULT_MARGIN_TOP = 40;\n","import { BaseType, Selection } from \"d3-selection\";\n\nimport {\n  maybeTransition,\n  RenderOptions,\n} from \"@/charts/shared/rendering-utils\";\nimport { DISABLE_SCREENSHOT_COLOR_WIPE_KEY } from \"@/components/chart-shared\";\n\nexport type RenderTotalValueLabelDatum = {\n  key: string;\n  x: number;\n  y: number;\n  valueLabel: string;\n};\n\nexport const renderTotalValueLabels = (\n  g: Selection<SVGGElement, null, SVGGElement, unknown>,\n  data: RenderTotalValueLabelDatum[],\n  options: RenderOptions & {\n    rotate: boolean;\n    textAnchor?: \"start\" | \"middle\" | \"end\";\n    dx?: number;\n    dy?: number;\n    fontSize: number;\n    fontFamily: string;\n    strokeWidth?: number;\n  }\n) => {\n  const {\n    transition,\n    rotate,\n    textAnchor: _textAnchor,\n    dx = 0,\n    dy = -8,\n    fontFamily,\n    fontSize,\n    strokeWidth = 3,\n  } = options;\n  const textAnchor = _textAnchor ?? getValueLabelTextAnchor(rotate);\n\n  g.selectAll<SVGTextElement, RenderTotalValueLabelDatum>(\"text\")\n    .data(data, (d) => d.key)\n    .join(\n      (enter) =>\n        enter\n          .append(\"text\")\n          .attr(\"font-size\", fontSize)\n          .attr(\"font-family\", fontFamily)\n          .attr(\"text-anchor\", textAnchor)\n          .attr(\"paint-order\", \"stroke\")\n          .attr(\"stroke\", \"white\")\n          .attr(\"stroke-width\", strokeWidth)\n          .style(\"transform\", (d) =>\n            getValueLabelTransform(d, {\n              rotate,\n              labelHeight: fontSize,\n              dx,\n              dy,\n            })\n          )\n          .style(\"line-height\", 1)\n          .style(\"opacity\", 0)\n          .text((d) => d.valueLabel)\n          .call((enter) =>\n            maybeTransition(enter, {\n              transition,\n              s: (g) => g.style(\"opacity\", 1),\n            })\n          ),\n      (update) =>\n        maybeTransition(update, {\n          s: (g) =>\n            g\n              .attr(\"text-anchor\", textAnchor)\n              .style(\"transform\", (d) =>\n                getValueLabelTransform(d, {\n                  rotate,\n                  labelHeight: fontSize,\n                  dx,\n                  dy,\n                })\n              )\n              .style(\"opacity\", 1)\n              .text((d) => d.valueLabel),\n          transition,\n        }),\n      (exit) =>\n        maybeTransition(exit, {\n          transition,\n          s: (g) => g.style(\"opacity\", 0).remove(),\n        })\n    );\n};\n\nconst getValueLabelTransform = (\n  d: RenderTotalValueLabelDatum,\n  {\n    rotate,\n    labelHeight,\n    dx,\n    dy,\n  }: {\n    rotate: boolean;\n    labelHeight: number;\n    dx: number;\n    dy: number;\n  }\n) => {\n  if (rotate) {\n    return `translate(${d.x + labelHeight / 3}px, ${d.y - (labelHeight * 2) / 3}px) rotate(-90deg)`;\n  }\n\n  return `translate(${d.x + dx}px, ${d.y + dy}px) rotate(0deg)`;\n};\n\nconst getValueLabelTextAnchor = (rotate: boolean) => {\n  return rotate ? \"start\" : \"middle\";\n};\n\nexport const setSegmentWrapperValueLabelProps = <\n  T extends { valueLabel?: string; valueLabelColor?: string },\n>(\n  g: Selection<BaseType, T, SVGGElement, null>\n) => {\n  return g\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"align-items\", \"center\")\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"100%\")\n    .style(\"padding\", \"2px\");\n};\n\nexport const setSegmentValueLabelProps = <\n  T extends { valueLabel?: string; valueLabelColor?: string },\n>(\n  g: Selection<BaseType, T, SVGGElement, null>\n) => {\n  return g\n    .attr(DISABLE_SCREENSHOT_COLOR_WIPE_KEY, true)\n    .style(\"overflow\", \"hidden\")\n    .style(\"font-size\", \"12px\")\n    .style(\"white-space\", \"nowrap\")\n    .style(\"text-overflow\", \"ellipsis\");\n};\n","import { ScaleLinear } from \"d3-scale\";\nimport { useCallback, useMemo } from \"react\";\n\nimport { AreasState } from \"@/charts/area/areas-state\";\nimport { LinesState } from \"@/charts/line/lines-state\";\nimport {\n  NumericalValueGetter,\n  NumericalXErrorVariables,\n  NumericalYErrorVariables,\n  useChartState,\n} from \"@/charts/shared/chart-state\";\nimport { RenderTotalValueLabelDatum } from \"@/charts/shared/render-value-labels\";\nimport { useChartFormatters } from \"@/charts/shared/use-chart-formatters\";\nimport { useChartTheme } from \"@/charts/shared/use-chart-theme\";\nimport {\n  AreaFields,\n  BarFields,\n  ColumnFields,\n  LineFields,\n} from \"@/config-types\";\nimport { Dimension, Measure, Observation } from \"@/domain/data\";\nimport { truthy } from \"@/domain/types\";\nimport { formatNumberWithUnit, useFormatNumber } from \"@/formatters\";\nimport { getTextWidth } from \"@/utils/get-text-width\";\n\nexport type ShowBandValueLabelsVariables = {\n  offset: number;\n  getValueOffset: (observation: Observation) => number;\n  showValues: boolean;\n  rotateValues: boolean;\n  renderEveryNthValue: number;\n  valueLabelFormatter: ValueLabelFormatter;\n};\n\nexport const useShowBandValueLabelsVariables = (\n  measureField: BarFields[\"x\"] | ColumnFields[\"y\"],\n  {\n    chartData,\n    dimensions,\n    measures,\n    getValue,\n    getErrorRange,\n    scale,\n    bandwidth,\n  }: {\n    chartData: Observation[];\n    dimensions: Dimension[];\n    measures: Measure[];\n    getValue: NumericalValueGetter;\n    getErrorRange?:\n      | NumericalXErrorVariables[\"getXErrorRange\"]\n      | NumericalYErrorVariables[\"getYErrorRange\"];\n    scale: ScaleLinear<number, number>;\n    bandwidth?: number;\n  }\n): ShowBandValueLabelsVariables => {\n  const { showValues = false } = measureField;\n  const measure = measures.find((d) => d.id === measureField.componentId);\n\n  if (!measure) {\n    throw Error(\n      `No dimension <${measureField.componentId}> in cube! (useShowBandValueLabelsVariables)`\n    );\n  }\n\n  const disableRotation = !bandwidth;\n  const horizontal = disableRotation;\n  const { labelFontSize: fontSize } = useChartTheme();\n  const renderEveryNthValue =\n    disableRotation || bandwidth > fontSize\n      ? 1\n      : Math.ceil(fontSize / bandwidth);\n\n  const valueLabelFormatter = useValueLabelFormatter({\n    measureId: measure.id,\n    dimensions,\n    measures,\n  });\n\n  const getValueOffset: ShowBandValueLabelsVariables[\"getValueOffset\"] =\n    useCallback(\n      (observation: Observation) => {\n        const value = getValue(observation);\n\n        if (value === null) {\n          return 0;\n        }\n\n        const errorEnd = getErrorRange?.(observation)[1];\n\n        if (errorEnd === undefined) {\n          return 0;\n        }\n\n        if (horizontal) {\n          return scale(errorEnd - value);\n        }\n\n        return scale(errorEnd) - scale(value);\n      },\n      [getValue, getErrorRange, horizontal, scale]\n    );\n\n  const { offset, rotateValues } = useMemo(() => {\n    let offset = 0;\n    let rotateValues = false;\n\n    if (showValues) {\n      let maxWidth = 0;\n\n      chartData.forEach((d) => {\n        const value = getValue(d);\n        const formattedValue = valueLabelFormatter(value);\n        const width = getTextWidth(formattedValue, { fontSize });\n\n        if (!disableRotation && width - 2 > bandwidth) {\n          rotateValues = true;\n        }\n\n        if (width > maxWidth) {\n          maxWidth = width;\n        }\n      });\n\n      if (disableRotation || rotateValues) {\n        offset = maxWidth;\n      } else {\n        offset = fontSize;\n      }\n    }\n\n    return {\n      offset,\n      rotateValues,\n    };\n  }, [\n    showValues,\n    chartData,\n    disableRotation,\n    getValue,\n    valueLabelFormatter,\n    fontSize,\n    bandwidth,\n  ]);\n\n  return {\n    offset,\n    getValueOffset,\n    showValues,\n    rotateValues,\n    renderEveryNthValue,\n    valueLabelFormatter,\n  };\n};\n\nexport type ShowTemporalValueLabelsVariables = {\n  yOffset: number;\n  showValues: boolean;\n  valueLabelFormatter: ValueLabelFormatter;\n};\n\nexport const useShowTemporalValueLabelsVariables = (\n  y: AreaFields[\"y\"] | LineFields[\"y\"],\n  {\n    dimensions,\n    measures,\n    segment,\n  }: {\n    dimensions: Dimension[];\n    measures: Measure[];\n    segment: AreaFields[\"segment\"] | LineFields[\"segment\"];\n  }\n): ShowTemporalValueLabelsVariables => {\n  const { showValues: _showValues = false } = y;\n  const yMeasure = measures.find((d) => d.id === y.componentId);\n\n  if (!yMeasure) {\n    throw Error(\n      `No dimension <${y.componentId}> in cube! (useShowLineValueLabelsVariables)`\n    );\n  }\n\n  const { labelFontSize: fontSize } = useChartTheme();\n\n  const valueLabelFormatter = useValueLabelFormatter({\n    measureId: yMeasure.id,\n    dimensions,\n    measures,\n  });\n\n  const showValues = _showValues && !segment;\n\n  return {\n    yOffset: showValues ? fontSize : 0,\n    showValues,\n    valueLabelFormatter,\n  };\n};\n\ntype RenderTemporalValueLabelDatum = RenderTotalValueLabelDatum & {\n  width: number;\n};\n\nexport const useRenderTemporalValueLabelsData = () => {\n  const {\n    bounds: {\n      width,\n      height,\n      margins: { left, right },\n    },\n    showValues,\n    chartData,\n    xScale,\n    getX,\n    getXAsString,\n    yScale,\n    getY,\n    valueLabelFormatter,\n  } = useChartState() as AreasState | LinesState;\n  const { labelFontSize: fontSize } = useChartTheme();\n  const valueLabelWidthsByIndex = useMemo(() => {\n    return chartData.reduce((acc, d, i) => {\n      const formattedValue = valueLabelFormatter(getY(d));\n      const width = getTextWidth(formattedValue, { fontSize });\n      acc[i] = width;\n\n      return acc;\n    }, {}) as Record<number, number>;\n  }, [chartData, valueLabelFormatter, getY, fontSize]);\n  const valueLabelsData: RenderTemporalValueLabelDatum[] = useMemo(() => {\n    if (!showValues || !width || !height) {\n      return [];\n    }\n\n    const previousArray: RenderTemporalValueLabelDatum[] = [];\n\n    return chartData\n      .map((d, i) => {\n        const labelWidth = valueLabelWidthsByIndex[i] ?? 0;\n        const key = getXAsString(d);\n        const valueRaw = getY(d);\n        const xScaled = xScale(getX(d)) as number;\n        const value = valueRaw === null || isNaN(valueRaw) ? 0 : valueRaw;\n        const yRender = yScale(Math.max(value, 0));\n        const valueLabel = valueLabelFormatter(value);\n\n        const padding = 8;\n        const xScaledInBounds = Math.min(\n          Math.max(\n            Math.min(left - labelWidth / 2 + padding, labelWidth / 2),\n            xScaled\n          ),\n          width - right - left - labelWidth / 2 + padding\n        );\n\n        const datum: RenderTemporalValueLabelDatum = {\n          key,\n          x: xScaledInBounds,\n          y: yRender,\n          valueLabel,\n          width: labelWidth,\n        };\n\n        const isOverlapping = getIsOverlapping({\n          previousArray,\n          current: datum,\n          labelHeight: fontSize,\n        });\n\n        if (isOverlapping) {\n          return null;\n        }\n\n        previousArray.push(datum);\n\n        return datum;\n      })\n      .filter(truthy);\n  }, [\n    showValues,\n    width,\n    height,\n    chartData,\n    valueLabelWidthsByIndex,\n    getXAsString,\n    getY,\n    xScale,\n    getX,\n    yScale,\n    valueLabelFormatter,\n    left,\n    right,\n    fontSize,\n  ]);\n\n  return valueLabelsData;\n};\n\nexport const getIsOverlapping = ({\n  previousArray,\n  current,\n  labelHeight,\n  horizontalOffset = 8,\n}: {\n  previousArray: RenderTemporalValueLabelDatum[];\n  current: RenderTemporalValueLabelDatum;\n  labelHeight: number;\n  horizontalOffset?: number;\n}) => {\n  return previousArray.some((previous) => {\n    return (\n      Math.abs(current.x - previous.x) - horizontalOffset <\n        previous.width / 2 + current.width / 2 &&\n      Math.abs(current.y - previous.y) < labelHeight\n    );\n  });\n};\n\nexport type ValueLabelFormatter = ReturnType<typeof useValueLabelFormatter>;\n\nexport const useValueLabelFormatter = ({\n  measureId,\n  dimensions,\n  measures,\n  normalize,\n}: {\n  measureId: string;\n  dimensions: Dimension[];\n  measures: Measure[];\n  normalize?: boolean;\n}) => {\n  const formatPercent = useFormatNumber({ decimals: 0 });\n  const formatNumber = useFormatNumber({ decimals: \"auto\" });\n  const formatters = useChartFormatters({ dimensions, measures });\n  const valueFormatter = normalize\n    ? formatPercent\n    : (formatters[measureId] ?? formatNumber);\n\n  return useCallback(\n    (value: number | null) => {\n      return formatNumberWithUnit(value, valueFormatter);\n    },\n    [valueFormatter]\n  );\n};\n","import { useMemo } from \"react\";\n\nimport { useDimensionFormatters } from \"@/formatters\";\n\nimport { BaseChartProps } from \"./chart-props\";\n\nexport const useChartFormatters = (\n  chartProps: Pick<BaseChartProps, \"dimensions\" | \"measures\">\n) => {\n  const { dimensions, measures } = chartProps;\n  const components = useMemo(\n    () => [...dimensions, ...measures],\n    [dimensions, measures]\n  );\n\n  return useDimensionFormatters(components);\n};\n","export const sortByIndex = <T>({\n  data,\n  order,\n  getCategory,\n  sortingOrder,\n}: {\n  data: T[];\n  order: string[];\n  getCategory: (datum: T) => string;\n  sortingOrder?: \"asc\" | \"desc\";\n}) => {\n  data.sort((a, b) => {\n    const A = getCategory(a);\n    const B = getCategory(b);\n    if (order.indexOf(A) > order.indexOf(B)) {\n      return sortingOrder === \"asc\" ? 1 : -1;\n    } else {\n      return sortingOrder === \"asc\" ? -1 : 1;\n    }\n  });\n\n  return data;\n};\n"],"names":["AxisHideXOverflowRect","bounds","chartWidth","chartHeight","margins","top","left","bottom","useChartState","_jsx","x","y","width","height","fill","AxisHideYOverflowRect","Limits","_ref","renderData","isHorizontal","id","transform","children","map","limit","_jsxs","MiddleLine","symbolType","className","LimitSymbol","LimitLines","key","_ref2","x1","x2","y1","y2","stroke","strokeWidth","strokeDasharray","lineType","_ref3","props","cx","cy","CircleSymbol","_objectSpread","CrossSymbol","TriangleSymbol","_ref4","r","LIMIT_SIZE","_ref5","_Fragment","CrossSymbolArm","rotation","_ref6","armWidth","style","transformBox","transformOrigin","_ref7","d","_ref8","LimitLine","type","_ref9","isRange","size","createLimitsComponent","getChartState","Component","axisDimension","limits","xScale","yScale","getX","getY","getAxisValue","axisDimensionScale","measureScale","chartSize","useMemo","length","isBandScale","limitSize","bandwidth","flatMap","configLimit","measureLimit","relatedAxisDimensionValueLabel","axis1Value","axis2Value","measure1Value","measure2Value","getLimitValues","observationKey","observationLabel","axisDimensionId","axis1","axis2","measure1","measure2","related","dimensionId","value","join","undefined","axisOffset","hasNoAxis","datum","color","hasValidAxis","displayName","min","max","timeFrom","find","label","timeTo","DEFAULT_MARGIN_TOP","renderTotalValueLabels","g","data","options","transition","rotate","textAnchor","_textAnchor","dx","dy","fontFamily","fontSize","getValueLabelTextAnchor","selectAll","enter","append","attr","getValueLabelTransform","labelHeight","text","valueLabel","call","maybeTransition","s","update","exit","remove","setSegmentWrapperValueLabelProps","setSegmentValueLabelProps","DISABLE_SCREENSHOT_COLOR_WIPE_KEY","useShowBandValueLabelsVariables","measureField","chartData","dimensions","measures","getValue","getErrorRange","scale","showValues","measure","componentId","Error","disableRotation","labelFontSize","useChartTheme","renderEveryNthValue","Math","ceil","valueLabelFormatter","useValueLabelFormatter","measureId","getValueOffset","useCallback","observation","errorEnd","offset","rotateValues","maxWidth","forEach","formattedValue","getTextWidth","useShowTemporalValueLabelsVariables","segment","_showValues","yMeasure","yOffset","useRenderTemporalValueLabelsData","right","getXAsString","valueLabelWidthsByIndex","reduce","acc","i","previousArray","labelWidth","valueRaw","xScaled","isNaN","current","push","filter","truthy","getIsOverlapping","horizontalOffset","some","previous","abs","normalize","formatPercent","useFormatNumber","decimals","formatNumber","formatters","useChartFormatters","valueFormatter","formatNumberWithUnit","chartProps","components","useDimensionFormatters","sortByIndex","order","getCategory","sortingOrder","sort","a","b","A","B","indexOf"],"sourceRoot":""}