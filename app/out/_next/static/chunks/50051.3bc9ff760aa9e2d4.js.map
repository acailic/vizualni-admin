{"version":3,"file":"static/chunks/50051.3bc9ff760aa9e2d4.js","mappings":"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","sources":["webpack://_N_E/./charts/shared/brush/index.tsx"],"sourcesContent":["import { useEventCallback } from \"@mui/material\";\nimport { bisector } from \"d3-array\";\nimport { BrushSelection, brushX } from \"d3-brush\";\nimport { pointer, pointers, select, Selection } from \"d3-selection\";\nimport { Transition } from \"d3-transition\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport type { AreasState } from \"@/charts/area/areas-state\";\nimport type { BarsState } from \"@/charts/bar/bars-state\";\nimport type { ColumnsState } from \"@/charts/column/columns-state\";\nimport type { LinesState } from \"@/charts/line/lines-state\";\nimport { makeGetClosestDatesFromDateRange } from \"@/charts/shared/brush/utils\";\nimport type {\n  ChartWithInteractiveXTimeRangeState,\n  ChartWithInteractiveYTimeRangeState,\n} from \"@/charts/shared/chart-state\";\nimport { useChartState } from \"@/charts/shared/chart-state\";\nimport { useChartTheme } from \"@/charts/shared/use-chart-theme\";\nimport { DashboardTimeRangeFilter } from \"@/configurator\";\nimport {\n  Observation,\n  TemporalDimension,\n  TemporalEntityDimension,\n} from \"@/domain/data\";\nimport { useTimeFormatUnit } from \"@/formatters\";\nimport {\n  useChartInteractiveFilters,\n  useInteractiveFiltersGetState,\n} from \"@/stores/interactive-filters\";\nimport { useTransitionStore } from \"@/stores/transition\";\nimport { getTextWidth } from \"@/utils/get-text-width\";\nimport { DISABLE_SCREENSHOT_ATTR } from \"@/utils/use-screenshot\";\n\nconst HANDLE_HEIGHT = 12;\nconst BRUSH_HEIGHT = 4;\nconst HEIGHT = HANDLE_HEIGHT + BRUSH_HEIGHT;\n\nexport const shouldShowBrush = (\n  interactiveFiltersConfig: { timeRange: { active: boolean } },\n  dashboardTimeRange: DashboardTimeRangeFilter | undefined\n) => {\n  const chartTimeRange = interactiveFiltersConfig.timeRange;\n  return !dashboardTimeRange?.active && chartTimeRange?.active;\n};\n\nexport const BrushTime = ({ yOffset }: { yOffset?: number }) => {\n  const ref = useRef<SVGGElement>(null);\n  const timeRange = useChartInteractiveFilters((d) => d.timeRange);\n  const setTimeRange = useChartInteractiveFilters((d) => d.setTimeRange);\n  const getInteractiveFiltersState = useInteractiveFiltersGetState();\n  const setEnableTransition = useTransitionStore((d) => d.setEnable);\n  const setBrushing = useTransitionStore((d) => d.setBrushing);\n  const [brushedIsEnded, updateBrushEndedStatus] = useState(true);\n  const [selectionExtent, setSelectionExtent] = useState(0);\n  const updateSelectionExtent = (selection: [number, number] | undefined) => {\n    if (selection) {\n      setSelectionExtent(selection[1] - selection[0]);\n    } else {\n      setSelectionExtent(0);\n    }\n  };\n  const {\n    brushOverlayColor,\n    brushSelectionColor,\n    brushHandleStrokeColor,\n    brushHandleFillColor,\n    labelFontSize,\n  } = useChartTheme();\n  const { bounds, xScaleTimeRange, xDimension } =\n    useChartState() as ChartWithInteractiveXTimeRangeState;\n  const { chartType } = useChartState() as\n    | ChartWithInteractiveYTimeRangeState\n    | ChartWithInteractiveXTimeRangeState;\n  const { yScaleTimeRange, yDimension } =\n    useChartState() as ChartWithInteractiveYTimeRangeState;\n  const formatDateUnit = useTimeFormatUnit();\n  const formatDate = (date: Date) => {\n    if (chartType === \"bar\") {\n      return formatDateUnit(\n        date,\n        (yDimension as TemporalDimension | TemporalEntityDimension).timeUnit\n      );\n    }\n    return formatDateUnit(\n      date,\n      (xDimension as TemporalDimension | TemporalEntityDimension).timeUnit\n    );\n  };\n  const { getX } = useChartState() as LinesState | AreasState;\n  const { getXAsDate, allData } = useChartState() as ColumnsState;\n  const { getYAsDate } = useChartState() as BarsState;\n  const getDate = (() => {\n    if (chartType === \"bar\") {\n      return getYAsDate;\n    }\n\n    if (chartType === \"column\" || chartType === \"comboLineColumn\") {\n      return getXAsDate;\n    }\n\n    return getX;\n  })();\n  const fullData = allData;\n\n  // Brush dimensions\n  const { width, margins, chartHeight } = bounds;\n  const scaleTimeRange =\n    chartType === \"bar\" ? yScaleTimeRange : xScaleTimeRange;\n\n  let { from, to } = timeRange;\n\n  // FIXME: Should be fixed in useSyncInteractiveFilters where we try to parse\n  // the date that can be a string (VISUALIZE_MOST_RECENT_VALUE).\n  if (isNaN(to?.getTime() ?? 0)) {\n    to = scaleTimeRange.domain()[1];\n  }\n\n  const brushLabelsWidth =\n    getTextWidth(formatDate(scaleTimeRange.domain()[0]), {\n      fontSize: labelFontSize,\n    }) +\n    getTextWidth(\" - \", { fontSize: labelFontSize }) +\n    getTextWidth(formatDate(scaleTimeRange.domain()[1]), {\n      fontSize: labelFontSize,\n    }) +\n    HANDLE_HEIGHT;\n  const brushWidth = width - brushLabelsWidth - margins.right;\n  const brushWidthScale = scaleTimeRange.copy();\n\n  brushWidthScale.range([0, brushWidth]);\n\n  const [minBrushDomainValue, maxBrushDomainValue] = useMemo(\n    () => brushWidthScale.domain().map((d) => d.getTime()),\n    [brushWidthScale]\n  );\n\n  const getClosestObservationFromRangeDates = useCallback(\n    ([from, to]: [Date, Date]): [Date, Date] => {\n      const getClosestDatesFromDateRange = makeGetClosestDatesFromDateRange(\n        fullData.sort((a, b) => getDate(a).getTime() - getDate(b).getTime()),\n        getDate\n      );\n\n      return getClosestDatesFromDateRange(from, to);\n    },\n    [fullData, getDate]\n  );\n\n  const [closestFrom, closestTo] = useMemo(() => {\n    if (from && to) {\n      return getClosestObservationFromRangeDates([from, to]);\n    } else {\n      return brushWidthScale.domain();\n    }\n  }, [from, getClosestObservationFromRangeDates, to, brushWidthScale]);\n\n  const brushed = useEventCallback(\n    ({ selection }: { selection: [number, number] }) => {\n      updateBrushEndedStatus(false);\n\n      if (selection) {\n        const [xStart, xEnd] = selection.map((s) => brushWidthScale.invert(s));\n        const [newFrom, newTo] = getClosestObservationFromRangeDates([\n          xStart,\n          xEnd,\n        ]);\n\n        // Need to use current state as the function is not updated during brushing\n        // and the local state accessed here is not up to date. This leads to\n        // making a dispatch on each brush move, which makes the animations laggy\n        // and generally shouldn't happen.\n        const { from, to } = getInteractiveFiltersState().timeRange;\n\n        if (\n          from?.getTime() !== newFrom.getTime() ||\n          to?.getTime() !== newTo.getTime()\n        ) {\n          setTimeRange(newFrom, newTo);\n        }\n      }\n    }\n  );\n\n  // Creates a 1-dimensional brush\n  const brush = brushX()\n    .extent([\n      [0, 0],\n      [brushWidth, BRUSH_HEIGHT],\n    ])\n    .on(\"start\", (e) => {\n      brushed(e);\n\n      if (e.sourceEvent instanceof MouseEvent) {\n        setEnableTransition(false);\n        setBrushing(true);\n      }\n    })\n    .on(\"brush\", brushed)\n    .on(\"end\", function (e) {\n      updateSelectionExtent(e.selection);\n\n      // Happens when snapping to actual values.\n      if (!e.sourceEvent) {\n        updateBrushEndedStatus(false);\n      } else {\n        // End event fires twice on touchend (MouseEvent and TouchEvent),\n        // we want to compute mx basing on MouseEvent.\n        if (e.sourceEvent instanceof MouseEvent) {\n          setEnableTransition(true);\n          setBrushing(false);\n\n          if (!e.selection && ref.current) {\n            const g = select(ref.current);\n            const [mx] = pointer(e, this);\n            const x = mx < 0 ? 0 : mx > brushWidth ? brushWidth : mx;\n            g.call(brush.move, [x, x]);\n          }\n        }\n\n        updateBrushEndedStatus(true);\n      }\n    });\n\n  /** Keyboard support */\n  const moveBrushOnKeyPress = useCallback(\n    (event: $FixMe, handleDirection: \"w\" | \"e\") => {\n      if (from && to) {\n        updateBrushEndedStatus(false);\n\n        const bisectDateLeft = bisector(\n          (ds: Observation, date: Date) =>\n            getDate(ds).getTime() - date.getTime()\n        ).left;\n        const bisectDateRight = bisector(\n          (ds: Observation, date: Date) =>\n            getDate(ds).getTime() - date.getTime()\n        ).right;\n\n        if (event.keyCode === 37 && handleDirection === \"w\") {\n          // west handle, moving left\n          const index = bisectDateLeft(fullData, from, 1);\n          const indexLeft = fullData[index - 1];\n\n          if (getDate(indexLeft).getTime() < to.getTime()) {\n            // new lower than \"to\"\n            setTimeRange(getDate(indexLeft), to);\n          } else {\n            // new too high, don't do anything\n            setTimeRange(from, to);\n          }\n        } else if (event.keyCode === 39 && handleDirection === \"w\") {\n          // west handle, moving right\n          const index = bisectDateRight(fullData, from, 1);\n          const indexRight = fullData[index];\n          if (getDate(indexRight).getTime() < to.getTime()) {\n            setTimeRange(getDate(indexRight), to);\n          } else {\n            setTimeRange(from, to);\n          }\n        } else if (event.keyCode === 37 && handleDirection === \"e\") {\n          // east handle, moving left\n          const index = bisectDateLeft(fullData, to, 1);\n          const indexLeft = fullData[index - 1];\n\n          if (getDate(indexLeft).getTime() > from.getTime()) {\n            setTimeRange(from, getDate(indexLeft));\n          } else {\n            setTimeRange(from, to);\n          }\n        } else if (event.keyCode === 39 && handleDirection === \"e\") {\n          // east handle, moving right\n          const index = bisectDateRight(fullData, to, 1);\n          const indexLeft = fullData[index];\n\n          if (indexLeft && getDate(indexLeft).getTime() > from.getTime()) {\n            setTimeRange(from, getDate(indexLeft));\n          } else {\n            setTimeRange(from, to);\n          }\n        }\n        updateBrushEndedStatus(true);\n      }\n    },\n    [fullData, setTimeRange, from, getDate, to]\n  );\n\n  useEffect(() => {\n    if (ref.current) {\n      const g = select<SVGGElement, unknown>(ref.current);\n      const mkBrush = (g: Selection<SVGGElement, unknown, null, undefined>) => {\n        g.call(brush);\n        g.select(\".overlay\")\n          .datum({ type: \"selection\" })\n          .attr(\"fill-opacity\", 0)\n          .style(\"y\", `-${HANDLE_HEIGHT / 2 - 1}px`)\n          .style(\"height\", HANDLE_HEIGHT)\n          .on(\n            \"mousedown touchstart\",\n            (e) => {\n              const [[cx]] = pointers(e);\n              const x0 = cx - selectionExtent / 2;\n              const x1 = cx + selectionExtent / 2;\n              const overflowingLeft = x0 < 0;\n              const overflowingRight = x1 > brushWidth;\n\n              g.call(\n                brush.move,\n                overflowingLeft\n                  ? [0, selectionExtent]\n                  : overflowingRight\n                    ? [brushWidth - selectionExtent, brushWidth]\n                    : [x0, x1]\n              );\n            },\n            { passive: true }\n          );\n        g.select(\".selection\")\n          .attr(\"fill\", brushSelectionColor)\n          .attr(\"fill-opacity\", 1)\n          .attr(\"stroke\", \"none\");\n        g.selectAll(\".handle\")\n          .attr(\"fill\", brushHandleFillColor)\n          .attr(\"stroke\", brushHandleStrokeColor)\n          .attr(\"stroke-width\", 2)\n          .style(\"y\", `-${BRUSH_HEIGHT}px`)\n          .style(\"width\", `${HANDLE_HEIGHT}px`)\n          .style(\"height\", `${HANDLE_HEIGHT}px`)\n          .attr(\"rx\", `${HANDLE_HEIGHT}px`);\n\n        g.select(\".handle--w\")\n          .attr(\"tabindex\", 0)\n          .on(\"keydown\", (e: $FixMe) => moveBrushOnKeyPress(e, \"w\"));\n        g.select(\".handle--e\")\n          .attr(\"tabindex\", 0)\n          .on(\"keydown\", (e: $FixMe) => moveBrushOnKeyPress(e, \"e\"));\n      };\n\n      g.call(mkBrush);\n    }\n  }, [\n    brush,\n    brushWidth,\n    brushHandleFillColor,\n    brushHandleStrokeColor,\n    brushOverlayColor,\n    brushSelectionColor,\n    moveBrushOnKeyPress,\n    selectionExtent,\n  ]);\n\n  // This effect allows \"snapping\" to actual data points\n  // after brush is ended and interactive-filters state is updated\n  const closestFromStr = closestFrom?.toString(); // Local variables to prevent eslint-plugin-react-hooks bug\n  const closestToStr = closestTo?.toString(); // leading to eslint crashing on this file\n  useEffect(() => {\n    const g = select(ref.current);\n    if (closestFrom && closestTo && brushedIsEnded) {\n      const coord = [brushWidthScale(closestFrom), brushWidthScale(closestTo)];\n      (\n        g.transition() as Transition<SVGGElement, unknown, null, undefined>\n      ).call(brush.move, coord);\n      updateBrushEndedStatus(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    brushWidthScale,\n    brushedIsEnded,\n    setTimeRange,\n    closestFromStr,\n    closestToStr,\n  ]);\n\n  // This effect resets brush defaults to editor values\n  // without transition\n  useEffect(() => {\n    const g = select(ref.current);\n    const defaultSelection: BrushSelection = [0, selectionExtent];\n    (g as Selection<SVGGElement, unknown, null, undefined>).call(\n      brush.move,\n      defaultSelection\n    );\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [minBrushDomainValue, maxBrushDomainValue]);\n\n  // This effect makes the brush responsive\n  useEffect(() => {\n    if (ref.current) {\n      const coord: BrushSelection = [\n        brushWidthScale(closestFrom),\n        brushWidthScale(closestTo),\n      ];\n      select<SVGGElement, unknown>(ref.current).call(brush.move, coord);\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [brushWidth]);\n\n  return fullData.length ? (\n    <g\n      {...DISABLE_SCREENSHOT_ATTR}\n      transform={`translate(0, ${yOffset ?? chartHeight + margins.top + margins.bottom - HEIGHT * 1.5})`}\n    >\n      {/* Selected Dates */}\n      <g>\n        {closestFrom && closestTo && (\n          <text\n            fontSize={labelFontSize}\n            textAnchor=\"start\"\n            x={0}\n            y={0}\n            dy={labelFontSize * 0.4}\n          >\n            {`${formatDate(closestFrom)} - ${formatDate(closestTo)}`}\n          </text>\n        )}\n      </g>\n\n      {/* Brush */}\n      <g transform={`translate(${brushLabelsWidth}, 0)`}>\n        {/* Visual overlay (functional overlay is managed by d3) */}\n        <rect\n          x={0}\n          y={0}\n          width={brushWidth}\n          height={BRUSH_HEIGHT}\n          fill={brushOverlayColor}\n        />\n      </g>\n      {/* actual Brush */}\n      <g ref={ref} transform={`translate(${brushLabelsWidth}, 0)`} />\n    </g>\n  ) : null;\n};\n\n// Unused BrushOrdinal\n\n// export const BrushOrdinal = ({ debug = false }: { debug?: boolean }) => {\n//   const ref = useRef<SVGGElement>(null);\n//   const [brushedIsEnded, updateBrushEndedStatus] = useState(true);\n\n//   const [state, dispatch] = useInteractiveFilters();\n//   const { from, to } = state.time;\n\n//   const {\n//     brushOverlayColor,\n//     brushSelectionColor,\n//     brushHandleStrokeColor,\n//     brushHandleFillColor,\n//     labelFontSize,\n//   } = useChartTheme();\n//   const {\n//     xEntireScale,\n//     getX,\n//     bounds,\n//     sortedData,\n//   } = useChartState() as ColumnsState;\n\n//   const updateBrushStatus = (event: $FixMe) => {\n//     const selection = event.selection;\n//     if (!event.sourceEvent || !selection) {\n//       updateBrushEndedStatus(false);\n//     } else {\n//       updateBrushEndedStatus(true);\n//     }\n//   };\n\n//   const brushed = ({ selection }: { selection: [number, number] }) => {\n//     updateBrushEndedStatus(false);\n//     if (selection) {\n//       const [xStart, xEnd] = selection;\n\n//       const range = xEntireScale.domain().map(xEntireScale) as number[];\n//       const startIndex = bisectLeft(range, xStart);\n//       const endIndex = bisectRight(range, xEnd);\n\n//       // Update interactive filters state\n//       dispatch({\n//         type: \"SET_TIME_RANGE_FILTER\",\n//         value: [startIndex, endIndex - 1],\n//       });\n//     }\n//   };\n\n//   // Creates a 1-dimensional brush\n//   const brush = brushX()\n//     .extent([\n//       [0, 0],\n//       [bounds.chartWidth, BRUSH_HEIGHT],\n//     ])\n//     .on(\"start brush\", brushed)\n//     .on(\"end.snap\", updateBrushStatus);\n\n//   /** Keyboard support */\n//   const moveBrushOnKeyPress = useCallback(\n//     (event: $FixMe, handleDirection: \"w\" | \"e\") => {\n//       updateBrushEndedStatus(false);\n\n//       if (event.keyCode === 37 && handleDirection === \"w\") {\n//         // west handle, moving left\n\n//         const indexLeft = from > 0 ? from - 1 : 0;\n\n//         if (indexLeft < to) {\n//           // new lower than \"to\"\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [indexLeft, to],\n//           });\n//         } else {\n//           // new too high, don't do anything\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [from, to],\n//           });\n//         }\n//       } else if (event.keyCode === 39 && handleDirection === \"w\") {\n//         // west handle, moving right\n\n//         const indexRight = from + 1;\n//         if (indexRight < to) {\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [indexRight, to],\n//           });\n//         } else {\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [from, to],\n//           });\n//         }\n//       } else if (event.keyCode === 37 && handleDirection === \"e\") {\n//         // east handle, moving left\n\n//         const indexLeft = to - 1;\n\n//         if (indexLeft > from) {\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [from, indexLeft],\n//           });\n//         } else {\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [from, to],\n//           });\n//         }\n//       } else if (event.keyCode === 39 && handleDirection === \"e\") {\n//         // east handle, moving right\n//         const indexRight = to < sortedData.length - 1 ? to + 1 : to;\n\n//         if (indexRight && indexRight > from) {\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [from, indexRight],\n//           });\n//         } else {\n//           dispatch({\n//             type: \"SET_TIME_RANGE_FILTER\",\n//             value: [from, to],\n//           });\n//         }\n//       }\n//       updateBrushEndedStatus(true);\n//     },\n//     [xEntireScale, from, to, dispatch, sortedData.length]\n//   );\n//   const mkBrush = useCallback(\n//     (g: Selection<SVGGElement, unknown, null, undefined>) => {\n//       g.select(\".overlay\")\n//         .attr(\"fill\", brushOverlayColor)\n//         .attr(\"fill-opacity\", 0.9);\n//       g.select(\".selection\")\n//         .attr(\"fill\", brushSelectionColor)\n//         .attr(\"fill-opacity\", 1)\n//         .attr(\"stroke\", \"none\");\n//       // .style(\"transform\", `translateX(${xEntireScale.step() / 2}px)`);\n\n//       g.selectAll(\".handle\")\n//         .attr(\"fill\", brushHandleFillColor)\n//         .attr(\"stroke\", brushHandleStrokeColor)\n//         .attr(\"stroke-width\", 2)\n//         .style(\"y\", `-${HANDLE_HEIGHT / 2}px`)\n//         // .style(\"transform\", `translateX(${xEntireScale.step() / 2}px)`)\n//         .style(\"width\", `${HANDLE_HEIGHT}px`)\n//         .style(\"height\", `${HANDLE_HEIGHT}px`)\n//         .attr(\"rx\", `${HANDLE_HEIGHT}px`);\n\n//       g.select(\".handle--w\")\n//         .attr(\"tabindex\", 0)\n//         .on(\"keydown\", (e: $FixMe) => moveBrushOnKeyPress(e, \"w\"));\n//       g.select(\".handle--e\")\n//         .attr(\"tabindex\", 0)\n//         .on(\"keydown\", (e: $FixMe) => moveBrushOnKeyPress(e, \"e\"));\n\n//       // Apply brush to selected group\n//       g.call(brush);\n//     },\n//     [\n//       brush,\n//       brushHandleFillColor,\n//       brushHandleStrokeColor,\n//       brushOverlayColor,\n//       brushSelectionColor,\n//       moveBrushOnKeyPress,\n//     ]\n//   );\n\n//   useEffect(() => {\n//     const g = select(ref.current);\n//     mkBrush(g as Selection<SVGGElement, unknown, null, undefined>);\n//   }, [mkBrush]);\n\n//   // This effect allow \"snapping\" to actual data points\n//   // after brush is ended and interactive-filters state is updated\n//   useEffect(() => {\n//     const g = select(ref.current);\n//     if ((from || from === 0) && to && brushedIsEnded) {\n//       const coord = [\n//         xEntireScale(getX(sortedData[from])),\n//         // Add the width of one step to mimic the visual behavior of BrushTime\n//         // - 1 to avoid trigerring a state change\n//         (xEntireScale(getX(sortedData[to])) || 0) + xEntireScale.step() - 1,\n//       ];\n\n//       (g.transition() as Transition<\n//         SVGGElement,\n//         unknown,\n//         null,\n//         undefined\n//       >).call(brush.move, coord);\n//     }\n//   }, [brush.move, from, to, xEntireScale, brushedIsEnded, getX, sortedData]);\n\n//   return (\n//     <>\n//       {/* Selected Dates */}\n//       <g\n//         transform={`translate(0, ${\n//           bounds.chartHeight + bounds.margins.top + bounds.margins.bottom\n//         })`}\n//       >\n//         {(from || from === 0) && to && (\n//           <text\n//             fontSize={labelFontSize}\n//             textAnchor=\"start\"\n//             x={0}\n//             y={0}\n//             dy={labelFontSize / 2}\n//           >\n//             {`${getX(sortedData[from])} - ${getX(sortedData[to])}`}\n//           </text>\n//         )}\n//       </g>\n\n//       {/* Data point location */}\n//       {debug && (\n//         <g\n//           transform={`translate(${bounds.margins.left}, ${\n//             bounds.chartHeight + bounds.margins.top + bounds.margins.bottom\n//           })`}\n//         >\n//           {xEntireScale\n//             .domain()\n//             .map(xEntireScale)\n//             .map((d, i) => (\n//               <>\n//                 <rect\n//                   x={d}\n//                   y={0}\n//                   width={xEntireScale.step()}\n//                   height={BRUSH_HEIGHT}\n//                   fill={\"crimson\"}\n//                   stroke={\"white\"}\n//                 />\n//                 <text\n//                   fontSize={7}\n//                   textAnchor=\"middle\"\n//                   x={(d ?? 0) + xEntireScale.step() / 2}\n//                   y={10}\n//                   dy={BRUSH_HEIGHT}\n//                   fill=\"crimson\"\n//                 >\n//                   {`${getX(sortedData[i])}`}\n//                 </text>\n//               </>\n//             ))}\n//         </g>\n//       )}\n//       {/* Brush */}\n//       <g\n//         ref={ref}\n//         transform={`translate(${bounds.margins.left}, ${\n//           bounds.chartHeight + bounds.margins.top + bounds.margins.bottom\n//         })`}\n//       />\n//     </>\n//   );\n// };\n"],"names":["shouldShowBrush","interactiveFiltersConfig","dashboardTimeRange","chartTimeRange","timeRange","active","BrushTime","_ref","yOffset","ref","useRef","useChartInteractiveFilters","d","setTimeRange","getInteractiveFiltersState","useInteractiveFiltersGetState","setEnableTransition","useTransitionStore","setEnable","setBrushing","brushedIsEnded","updateBrushEndedStatus","useState","selectionExtent","setSelectionExtent","updateSelectionExtent","selection","brushOverlayColor","brushSelectionColor","brushHandleStrokeColor","brushHandleFillColor","labelFontSize","useChartTheme","bounds","xScaleTimeRange","xDimension","useChartState","chartType","yScaleTimeRange","yDimension","formatDateUnit","useTimeFormatUnit","formatDate","date","timeUnit","getX","getXAsDate","allData","getYAsDate","getDate","width","margins","chartHeight","scaleTimeRange","from","to","isNaN","getTime","domain","brushLabelsWidth","getTextWidth","fontSize","brushWidth","right","brushWidthScale","copy","range","minBrushDomainValue","maxBrushDomainValue","useMemo","map","getClosestObservationFromRangeDates","useCallback","_ref2","getClosestDatesFromDateRange","makeGetClosestDatesFromDateRange","fullData","sort","a","b","closestFrom","closestTo","brushed","useEventCallback","_ref3","xStart","xEnd","s","invert","newFrom","newTo","brush","brushX","extent","on","e","sourceEvent","MouseEvent","current","g","select","mx","pointer","x","call","move","moveBrushOnKeyPress","event","handleDirection","bisectDateLeft","bisector","ds","left","bisectDateRight","keyCode","index","indexLeft","indexRight","useEffect","datum","type","attr","style","cx","pointers","x0","x1","overflowingLeft","overflowingRight","passive","selectAll","closestFromStr","toString","closestToStr","coord","transition","defaultSelection","length","_jsxs","_objectSpread","DISABLE_SCREENSHOT_ATTR","transform","top","bottom","HEIGHT","children","_jsx","textAnchor","y","dy","height","fill"],"sourceRoot":""}